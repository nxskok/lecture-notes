{
  "hash": "3d7e76841c72318896a07c5e9612628e",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Vector and matrix algebra\"\n---\n\n\n\n\n## Packages for this section\n\n- This is (almost) all base R! We only need this for one thing later:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n:::\n\n\n\n\n\n## Vector addition\n\n- Adding vectors:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nu <- c(2, 3, 6, 5, 7)\nv <- c(1, 8, 3, 2, 0)\nu + v\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  3 11  9  7  7\n```\n\n\n:::\n:::\n\n\n\n\n- Elementwise addition. (Linear algebra: vector addition.)\n\n## Adding a number to a vector\n\n- Define a vector, then “add 2” to it:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nu\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2 3 6 5 7\n```\n\n\n:::\n\n```{.r .cell-code}\nk <- 2\nu + k\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4 5 8 7 9\n```\n\n\n:::\n:::\n\n\n\n\n- adds 2 to *each* element of `u`.\n\n## Scalar multiplication\nAs per linear algebra:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nk\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n\n```{.r .cell-code}\nu\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2 3 6 5 7\n```\n\n\n:::\n\n```{.r .cell-code}\nk * u\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  4  6 12 10 14\n```\n\n\n:::\n:::\n\n\n\n\n- Each element of vector multiplied by 2.\n\n## “Vector multiplication”\nWhat about this?\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nu\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2 3 6 5 7\n```\n\n\n:::\n\n```{.r .cell-code}\nv\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 8 3 2 0\n```\n\n\n:::\n\n```{.r .cell-code}\nu * v\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  2 24 18 10  0\n```\n\n\n:::\n:::\n\n\n\n\nEach element of `u` multiplied by *corresponding* element of `v`. Could be\ncalled elementwise multiplication. \n\n(Don't confuse with “outer” or\n“vector” product from linear algebra, or indeed “inner” or “scalar” multiplication,\nfor which the answer is a number.)\n\n## Combining different-length vectors\n- No error here (you get a warning). What happens?\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nu\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2 3 6 5 7\n```\n\n\n:::\n\n```{.r .cell-code}\nw <- c(1, 2)\nu + w\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3 5 7 7 8\n```\n\n\n:::\n:::\n\n\n\n\n- Add 1 to first element of `u`, add 2 to second.\n- Go back to beginning of `w` to find something to add: add 1 to 3rd\nelement of `u`, 2 to 4th element, 1 to 5th. \n\n## How R does this \n\n- Keep re-using shorter vector until reach length of longer one.\n- “Recycling”.\n- If the longer vector's length not a multiple of the shorter vector's length, get a warning (probably not what you want). \n- Same idea is used when multiplying a vector by a number: the number\nkeeps getting recycled.\n\n## Matrices\n- Create matrix like this:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(A <- matrix(1:4, nrow = 2, ncol = 2))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n```\n\n\n:::\n:::\n\n\n\n\n- First: stuff to make matrix from, then how many rows and columns.\n- R goes down columns by default. To go along rows instead:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(B <- matrix(5:8, nrow = 2, ncol = 2, byrow = TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]    5    6\n[2,]    7    8\n```\n\n\n:::\n:::\n\n\n\n\n- One of `nrow` and `ncol` enough, since R knows how many things in\nthe matrix.\n\n## Adding matrices\nWhat happens if you add two matrices?\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nA\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n```\n\n\n:::\n\n```{.r .cell-code}\nB\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]    5    6\n[2,]    7    8\n```\n\n\n:::\n\n```{.r .cell-code}\nA + B\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]    6    9\n[2,]    9   12\n```\n\n\n:::\n:::\n\n\n\n\n## Adding matrices\n\n- Nothing surprising here. This is matrix addition as we and linear algebra know it.\n\n## Multiplying matrices\n- Now, what happens here?\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nA\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n```\n\n\n:::\n\n```{.r .cell-code}\nB\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]    5    6\n[2,]    7    8\n```\n\n\n:::\n\n```{.r .cell-code}\nA * B\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]    5   18\n[2,]   14   32\n```\n\n\n:::\n:::\n\n\n\n\n## Multiplying matrices?\n\n- *Not* matrix multiplication (as per linear algebra).\n- Elementwise multiplication. Also called *Hadamard product* of `A` and `B`.\n\n## Legit matrix multiplication\nLike this:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nA\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n```\n\n\n:::\n\n```{.r .cell-code}\nB\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]    5    6\n[2,]    7    8\n```\n\n\n:::\n\n```{.r .cell-code}\nA %*% B\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]   26   30\n[2,]   38   44\n```\n\n\n:::\n:::\n\n\n\n\n## Reading matrix from file\n- The usual:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_url <- \"http://ritsokiguess.site/datafiles/m.txt\"\nM <- read_delim(my_url, \" \", col_names = FALSE )\nM\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"X1\"],\"name\":[1],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"X2\"],\"name\":[2],\"type\":[\"dbl\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"10\",\"2\":\"9\"},{\"1\":\"8\",\"2\":\"7\"},{\"1\":\"6\",\"2\":\"5\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n\n```{.r .cell-code}\nclass(M)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"spec_tbl_df\" \"tbl_df\"      \"tbl\"         \"data.frame\" \n```\n\n\n:::\n:::\n\n\n\n\n## but...\n\n- except that M is not an R matrix, and thus this doesn’t work:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nv <- c(1, 3)\nM %*% v\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in M %*% v: requires numeric/complex matrix/vector arguments\n```\n\n\n:::\n:::\n\n\n\n\n## Making a genuine matrix\n\nDo this first:\n\n\\small\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nM <- as.matrix(M)\nM\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     X1 X2\n[1,] 10  9\n[2,]  8  7\n[3,]  6  5\n```\n\n\n:::\n\n```{.r .cell-code}\nv \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 3\n```\n\n\n:::\n:::\n\n\n\n\n\\normalsize\n\nand then all is good:\n\n\\small\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nM %*% v\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1]\n[1,]   37\n[2,]   29\n[3,]   21\n```\n\n\n:::\n:::\n\n\n\n\n\\normalsize\n\n## Linear algebra stuff\n\n- To solve system of equations\n$Ax = w$ for $x$:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nA\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n```\n\n\n:::\n\n```{.r .cell-code}\nw\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2\n```\n\n\n:::\n\n```{.r .cell-code}\nsolve(A, w)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 0\n```\n\n\n:::\n:::\n\n\n\n\n## Matrix inverse\n\n- To find the inverse of A:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nA\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n```\n\n\n:::\n\n```{.r .cell-code}\nsolve(A)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]   -2  1.5\n[2,]    1 -0.5\n```\n\n\n:::\n:::\n\n\n\n\n## Checking\n\nMatrix inverse:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nA %*% solve(A)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]    1    0\n[2,]    0    1\n```\n\n\n:::\n:::\n\n\n\n\nSystem of equations:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nA %*% solve(A, w)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1]\n[1,]    1\n[2,]    2\n```\n\n\n:::\n\n```{.r .cell-code}\nw\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2\n```\n\n\n:::\n:::\n\n\n\n\n\n- Thus, matrix inverse and equation solution are\ncorrect.\n\n## Inner product\n- Vectors in R are column vectors, so just do the matrix multiplication (`t()` is transpose): \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- c(1, 2, 3)\nb <- c(4, 5, 6)\nt(a) %*% b\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1]\n[1,]   32\n```\n\n\n:::\n:::\n\n\n\n\n- Note that the answer is actually a 1 × 1 matrix.\n- Or as the sum of the elementwise multiplication:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(a * b)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 32\n```\n\n\n:::\n:::\n\n\n\n\n## Accessing parts of vector\n\n- use square brackets and a number to get elements of a vector\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nb\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4 5 6\n```\n\n\n:::\n\n```{.r .cell-code}\nb[2]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5\n```\n\n\n:::\n:::\n\n\n\n\n## Accessing parts of matrix\n\n- use a row and column index to get an element of a matrix\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nA\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n```\n\n\n:::\n\n```{.r .cell-code}\nA[2,1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n:::\n\n\n\n\n- leave the row or column index empty to get whole row or column, eg.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nA[1,]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 3\n```\n\n\n:::\n:::\n\n\n\n\n\n\n## Eigenvalues and eigenvectors 1/2\n\n- For a matrix $A$, these are scalars $\\lambda$ and vectors $v$ that solve\n\n$$ A v = \\lambda v $$\n\n- In R, `eigen` gets these:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nA\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n```\n\n\n:::\n\n```{.r .cell-code}\ne <- eigen(A)\n```\n:::\n\n\n\n\n\n## Eigenvalues and eigenvectors 2/2\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ne\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\neigen() decomposition\n$values\n[1]  5.3722813 -0.3722813\n\n$vectors\n           [,1]       [,2]\n[1,] -0.5657675 -0.9093767\n[2,] -0.8245648  0.4159736\n```\n\n\n:::\n:::\n\n\n\n\n\n## Eigenvalues/vectors correct?\n\n- $\\lambda_1 v_1$: (scalar) multiply first eigenvalue by first eigenvector (in column)\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ne$values[1] * e$vectors[,1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] -3.039462 -4.429794\n```\n\n\n:::\n:::\n\n\n\n- $A v_1$: (matrix) multiply matrix by first eigenvector (in column)\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nA %*% e$vectors[,1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n          [,1]\n[1,] -3.039462\n[2,] -4.429794\n```\n\n\n:::\n:::\n\n\n\n\n- These are (correctly) equal.\n- The second one goes the same way.\n\n## A statistical application of eigenvalues\n\n- A negative correlation:\n\n\\footnotesize\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd <- tribble(\n  ~x,  ~y,\n  10,  20,\n  11,  18,\n  12,  17,\n  13,  14,\n  14,  13\n)\nv <- cor(d)\nv\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n           x          y\nx  1.0000000 -0.9878783\ny -0.9878783  1.0000000\n```\n\n\n:::\n:::\n\n\n\n\\normalsize\n\n- `cor` gives the correlation matrix between each pair of variables (correlation between `x` and `y` is $-0.988$)\n\n## Eigenanalysis of correlation matrix\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\neigen(v)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\neigen() decomposition\n$values\n[1] 1.98787834 0.01212166\n\n$vectors\n           [,1]       [,2]\n[1,] -0.7071068 -0.7071068\n[2,]  0.7071068 -0.7071068\n```\n\n\n:::\n:::\n\n\n\n\n- first eigenvalue much bigger than second (second one near zero)\n- two variables, but data nearly *one*-dimensional\n- opposite signs in first eigenvector indicate that the one dimension is:\n  - `x` small and `y` large at one end,\n  - `x` large and `y` small at the other.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<link href=\"vector_matrix_files/libs/pagedtable-1.1/css/pagedtable.css\" rel=\"stylesheet\" />\n<script src=\"vector_matrix_files/libs/pagedtable-1.1/js/pagedtable.js\"></script>\n"
      ],
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}