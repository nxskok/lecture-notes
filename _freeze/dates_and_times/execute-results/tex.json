{
  "hash": "6307bde5243f79b4de0cbda114db8d96",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Dates and Times\"\n---\n\n\n\n\n\n## Packages for this section\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n# library(lubridate)\n```\n:::\n\n\n\n\n`lubridate` is the package that handles dates and times, but is now part of the `tidyverse`, so no need to load separately.\n\n## Dates\n- Dates represented on computers as “days since an origin”,\ntypically Jan 1, 1970, with a negative date being before the origin: \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmydates <- c(\"1970-01-01\", \"2007-09-04\", \"1931-08-05\")\n(somedates <- tibble(text = mydates) %>%\n  mutate(\n    d = as.Date(text),\n    numbers = as.numeric(d)\n  ))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 x 3\n  text       d          numbers\n  <chr>      <date>       <dbl>\n1 1970-01-01 1970-01-01       0\n2 2007-09-04 2007-09-04   13760\n3 1931-08-05 1931-08-05  -14029\n```\n\n\n:::\n:::\n\n\n\n\n## Doing arithmetic with dates\n\n- Dates are \"actually\" numbers, so can add and subtract (difference is 2007 date in `d` minus others): \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsomedates %>% mutate(plus30 = d + 30, diffs = d[2] - d)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 x 5\n  text       d          numbers plus30     diffs     \n  <chr>      <date>       <dbl> <date>     <drtn>    \n1 1970-01-01 1970-01-01       0 1970-01-31 13760 days\n2 2007-09-04 2007-09-04   13760 2007-10-04     0 days\n3 1931-08-05 1931-08-05  -14029 1931-09-04 27789 days\n```\n\n\n:::\n:::\n\n\n\n\n## Reading in dates from a file\n- `read_csv` and the others can guess that you have dates, if you\nformat them as year-month-day, like column 1 of this `.csv`:\n\n```\ndate,status,dunno\n2011-08-03,hello,August 3 2011\n2011-11-15,still here,November 15 2011\n2012-02-01,goodbye,February 1 2012\n```\n\n- Then read them in:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_url <- \"http://ritsokiguess.site/datafiles/mydates.csv\"\nddd <- read_csv(my_url)\n```\n:::\n\n\n\n\n- read_csv guessed that the 1st column is dates, but not 3rd.\n\n## The data as read in\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nddd\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 x 3\n  date       status     dunno           \n  <date>     <chr>      <chr>           \n1 2011-08-03 hello      August 3 2011   \n2 2011-11-15 still here November 15 2011\n3 2012-02-01 goodbye    February 1 2012 \n```\n\n\n:::\n:::\n\n\n\n\n## Dates in other formats \n\n- Preceding shows that dates should be stored as text in format\nyyyy-mm-dd (ISO standard).\n- To deal with dates in other formats, use package `lubridate` and\nconvert. For example, dates in US format with month first:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntibble(usdates = c(\"05/27/2012\", \"01/03/2016\", \"12/31/2015\")) %>%\n  mutate(iso = mdy(usdates))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 x 2\n  usdates    iso       \n  <chr>      <date>    \n1 05/27/2012 2012-05-27\n2 01/03/2016 2016-01-03\n3 12/31/2015 2015-12-31\n```\n\n\n:::\n:::\n\n\n\n\n## Trying to read these as UK dates \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntibble(usdates = c(\"05/27/2012\", \"01/03/2016\", \"12/31/2015\")) %>%\n  mutate(uk = dmy(usdates))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 x 2\n  usdates    uk        \n  <chr>      <date>    \n1 05/27/2012 NA        \n2 01/03/2016 2016-03-01\n3 12/31/2015 NA        \n```\n\n\n:::\n:::\n\n\n\n\n- For UK-format dates with month second, one of these dates is legit (but wrong),\nbut the other two make no sense.\n\n## Our data frame's last column:\n\n- Back to this: \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nddd\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 x 3\n  date       status     dunno           \n  <date>     <chr>      <chr>           \n1 2011-08-03 hello      August 3 2011   \n2 2011-11-15 still here November 15 2011\n3 2012-02-01 goodbye    February 1 2012 \n```\n\n\n:::\n:::\n\n\n\n\n- Month, day,  year in that order.\n\n## so interpret as such\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(ddd %>% mutate(date2 = mdy(dunno)) -> d4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 x 4\n  date       status     dunno            date2     \n  <date>     <chr>      <chr>            <date>    \n1 2011-08-03 hello      August 3 2011    2011-08-03\n2 2011-11-15 still here November 15 2011 2011-11-15\n3 2012-02-01 goodbye    February 1 2012  2012-02-01\n```\n\n\n:::\n:::\n\n\n\n\n\n## Are they really the same? \n\n- Column `date2` was correctly converted from column `dunno`: \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd4 %>% mutate(equal = identical(date, date2))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 x 5\n  date       status     dunno            date2      equal\n  <date>     <chr>      <chr>            <date>     <lgl>\n1 2011-08-03 hello      August 3 2011    2011-08-03 TRUE \n2 2011-11-15 still here November 15 2011 2011-11-15 TRUE \n3 2012-02-01 goodbye    February 1 2012  2012-02-01 TRUE \n```\n\n\n:::\n:::\n\n\n\n\n- The two columns of dates are all the same.\n\n## Making dates from pieces\nStarting from this file:\n\n```\nyear month day\n1970 1 1\n2007 9 4\n1940 4 15\n```\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_url <- \"http://ritsokiguess.site/datafiles/pieces.txt\"\ndates0 <- read_delim(my_url, \" \")\n```\n:::\n\n\n\n\n## Making some dates \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndates0\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 x 3\n   year month   day\n  <dbl> <dbl> <dbl>\n1  1970     1     1\n2  2007     9     4\n3  1940     4    15\n```\n\n\n:::\n\n```{.r .cell-code}\ndates0 %>%\n  unite(dates, day, month, year) %>%\n  mutate(d = dmy(dates)) -> newdates\n```\n:::\n\n\n\n\n\n## The results\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnewdates\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 x 2\n  dates     d         \n  <chr>     <date>    \n1 1_1_1970  1970-01-01\n2 4_9_2007  2007-09-04\n3 15_4_1940 1940-04-15\n```\n\n\n:::\n:::\n\n\n\n\n- `unite` glues things together with an underscore between them (if you\ndon’t specify anything else). Syntax: first thing is new column to be\ncreated, other columns are what to make it out of.\n- `unite` makes the original variable columns year, month, day\n*disappear*.\n- The column `dates` is text, while `d` is a real date.\n\n## Extracting information from dates \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnewdates %>%\n  mutate(\n    mon = month(d),\n    day = day(d),\n    weekday = wday(d, label = TRUE)\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 x 5\n  dates     d            mon   day weekday\n  <chr>     <date>     <dbl> <int> <ord>  \n1 1_1_1970  1970-01-01     1     1 Thu    \n2 4_9_2007  2007-09-04     9     4 Tue    \n3 15_4_1940 1940-04-15     4    15 Mon    \n```\n\n\n:::\n:::\n\n\n\n\n## Dates and times\n- Standard format for times is to put the time after the date, hours,\nminutes, seconds:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(dd <- tibble(text = c(\n  \"1970-01-01 07:50:01\", \"2007-09-04 15:30:00\",\n  \"1940-04-15 06:45:10\", \"2016-02-10 12:26:40\"\n)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 x 1\n  text               \n  <chr>              \n1 1970-01-01 07:50:01\n2 2007-09-04 15:30:00\n3 1940-04-15 06:45:10\n4 2016-02-10 12:26:40\n```\n\n\n:::\n:::\n\n\n\n\n## Converting text to date-times: \n\n- Then get from this text using `ymd_hms`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndd %>% mutate(dt = ymd_hms(text)) %>% pull(dt)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"1970-01-01 07:50:01 UTC\" \"2007-09-04 15:30:00 UTC\"\n[3] \"1940-04-15 06:45:10 UTC\" \"2016-02-10 12:26:40 UTC\"\n```\n\n\n:::\n:::\n\n\n\n\n\n## Timezones\n\n- Default timezone is “Universal Coordinated Time”. Change it via `tz=`\nand the name of a timezone: \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndd %>% \n  mutate(dt = ymd_hms(text, tz = \"America/Toronto\")) -> dd\ndd %>% mutate(zone = tz(dt))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 x 3\n  text                dt                  zone           \n  <chr>               <dttm>              <chr>          \n1 1970-01-01 07:50:01 1970-01-01 07:50:01 America/Toronto\n2 2007-09-04 15:30:00 2007-09-04 15:30:00 America/Toronto\n3 1940-04-15 06:45:10 1940-04-15 06:45:10 America/Toronto\n4 2016-02-10 12:26:40 2016-02-10 12:26:40 America/Toronto\n```\n\n\n:::\n:::\n\n\n\n\n## Finding a timezone name\n\n- Use `OlsonNames()`. Some of them:\n\n\n\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsample(OlsonNames(), 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"Africa/Freetown\"           \"Asia/Seoul\"               \n [3] \"Asia/Macau\"                \"Pacific/Gambier\"          \n [5] \"America/Argentina/Mendoza\" \"Asia/Karachi\"             \n [7] \"Etc/GMT+0\"                 \"America/Antigua\"          \n [9] \"America/Whitehorse\"        \"Atlantic/Canary\"          \n```\n\n\n:::\n:::\n\n::: {.cell}\n\n:::\n\n\n\n\n\n## Extracting time parts\n- As you would expect: \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndd %>%\n  select(-text) %>%\n  mutate(\n    h = hour(dt), sec = second(dt),\n    min = minute(dt), zone = tz(dt)\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 x 5\n  dt                      h   sec   min zone           \n  <dttm>              <int> <dbl> <int> <chr>          \n1 1970-01-01 07:50:01     7     1    50 America/Toronto\n2 2007-09-04 15:30:00    15     0    30 America/Toronto\n3 1940-04-15 06:45:10     6    10    45 America/Toronto\n4 2016-02-10 12:26:40    12    40    26 America/Toronto\n```\n\n\n:::\n:::\n\n\n\n\n## Same times, but different time zone: \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndd %>%\n  select(dt) %>%\n  mutate(oz = with_tz(dt, \"Australia/Sydney\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 x 2\n  dt                  oz                 \n  <dttm>              <dttm>             \n1 1970-01-01 07:50:01 1970-01-01 22:50:01\n2 2007-09-04 15:30:00 2007-09-05 05:30:00\n3 1940-04-15 06:45:10 1940-04-15 21:45:10\n4 2016-02-10 12:26:40 2016-02-11 04:26:40\n```\n\n\n:::\n:::\n\n\n\n\n## In more detail \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndd %>%\n  mutate(oz = with_tz(dt, \"Australia/Sydney\")) %>%\n  pull(oz)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"1970-01-01 22:50:01 AEST\" \"2007-09-05 05:30:00 AEST\"\n[3] \"1940-04-15 21:45:10 AEST\" \"2016-02-11 04:26:40 AEDT\"\n```\n\n\n:::\n:::\n\n\n\n\n\"Australian Eastern Time\", Standard or Daylight. Note when the Australian summer is.\n\n\n## How long between date-times?\n\n- We may need to calculate the time between two events. For example,\nthese are the dates and times that some patients were admitted to\nand discharged from a hospital:\n\n```\nadmit,discharge\n1981-12-10 22:00:00,1982-01-03 14:00:00\n2014-03-07 14:00:00,2014-03-08 09:30:00\n2016-08-31 21:00:00,2016-09-02 17:00:00\n```\n\n## Do they get read in as date-times? \n\n- These ought to get read in and converted to date-times:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_url <- \"http://ritsokiguess.site/datafiles/hospital.csv\"\nstays <- read_csv(my_url)\nstays\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 x 2\n  admit               discharge          \n  <dttm>              <dttm>             \n1 1981-12-10 22:00:00 1982-01-03 14:00:00\n2 2014-03-07 14:00:00 2014-03-08 09:30:00\n3 2016-08-31 21:00:00 2016-09-02 17:00:00\n```\n\n\n:::\n:::\n\n\n\n\n-  and so it proves.\n\n## Subtracting the date-times\n\n- In the obvious way, this gets us an answer:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstays %>% mutate(stay = discharge - admit)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 x 3\n  admit               discharge           stay       \n  <dttm>              <dttm>              <drtn>     \n1 1981-12-10 22:00:00 1982-01-03 14:00:00 568.0 hours\n2 2014-03-07 14:00:00 2014-03-08 09:30:00  19.5 hours\n3 2016-08-31 21:00:00 2016-09-02 17:00:00  44.0 hours\n```\n\n\n:::\n:::\n\n\n\n\n- Number of hours; hard to interpret. \n\n## Days\n\n- Fractional number of days would\nbe better: \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstays %>% \n  mutate(\n    stay_days = as.period(admit %--% discharge) / days(1))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 x 3\n  admit               discharge           stay_days\n  <dttm>              <dttm>                  <dbl>\n1 1981-12-10 22:00:00 1982-01-03 14:00:00    23.7  \n2 2014-03-07 14:00:00 2014-03-08 09:30:00     0.812\n3 2016-08-31 21:00:00 2016-09-02 17:00:00     1.83 \n```\n\n\n:::\n:::\n\n\n\n\n## Completed days\n\n- Pull out with `day()` etc, as for a date-time:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstays %>% \n  mutate(\n    stay = as.period(admit %--% discharge),\n    stay_days = day(stay),\n    stay_hours = hour(stay)\n    ) %>%\n  select(starts_with(\"stay\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 x 3\n  stay          stay_days stay_hours\n  <Period>          <dbl>      <dbl>\n1 23d 16H 0M 0S        23         16\n2 19H 30M 0S            0         19\n3 1d 20H 0M 0S          1         20\n```\n\n\n:::\n:::\n\n\n\n\n\n## Comments\n- Date-times are stored internally as seconds-since-something, so that\nsubtracting two of them will give, internally, a number of seconds.\n- Just subtracting the date-times is displayed as a time (in units that R\nchooses for us).\n- Convert to fractional times via a \"period\", then divide by `days(1)`, `months(1)` etc.\n- These ideas useful for calculating time from a start point until an event\nhappens (in this case, a patient being discharged from hospital).\n\n",
    "supporting": [
      "dates_and_times_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": null,
    "postProcess": false
  }
}