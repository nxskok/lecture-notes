{
  "hash": "8db323941ffb0bb1d9ec391d31d86029",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Functions\"\neditor: \n  markdown: \n    wrap: 72\n---\n\n\n\n\n## Packages for this section\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(broom) # some regression stuff later\n```\n:::\n\n\n\n\n## Don’t repeat yourself\n\n-   See this:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- 50\nb <- 11\nd <- 3\nas <- sqrt(a - 1)\nas\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 7\n```\n\n\n:::\n\n```{.r .cell-code}\nbs <- sqrt(b - 1)\nbs\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3.162278\n```\n\n\n:::\n\n```{.r .cell-code}\nds <- sqrt(d - 1)\nds\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.414214\n```\n\n\n:::\n:::\n\n\n\n\n## What's the problem?\n\n-   Same calculation done three different times, by copying, pasting and\n    editing.\n\n-   Dangerous: what if you forget to change something after you pasted?\n\n-   Programming principle: \"don't repeat yourself\".\n\n-   Hadley Wickham: don't copy-paste more than twice.\n\n-   Instead: *write a function*.\n\n## Anatomy of function\n\n-   Header line with function name and input value(s).\n-   Body with calculation of values to output/return.\n-   Return value: the output from function. In our case:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsqrt_minus_1 <- function(x) {\n  ans <- sqrt(x - 1)\n  return(ans)\n}\n```\n:::\n\n\n\n\nor more simply (\"the R way\", better style)\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsqrt_minus_1 <- function(x) {\n  sqrt(x - 1)\n}\n```\n:::\n\n\n\n\nIf last line of function calculates value without saving it, that value\nis returned.\n\n## About the input; testing\n\n-   The input to a function can be called anything. Here we called it\n    `x`. This is the name used inside the function.\n-   The function is a “machine” for calculating square-root-minus-1. It\n    doesn’t do anything until you call it:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsqrt_minus_1(50)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 7\n```\n\n\n:::\n\n```{.r .cell-code}\nsqrt_minus_1(11)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3.162278\n```\n\n\n:::\n\n```{.r .cell-code}\nsqrt_minus_1(3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.414214\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nq <- 17\nsqrt_minus_1(q)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4\n```\n\n\n:::\n\n```{.r .cell-code}\nsqrt_minus_1(\"text\")\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in x - 1: non-numeric argument to binary operator\n```\n\n\n:::\n:::\n\n\n\n\n-   It works!\n\n## Vectorization 1/2\n\n-   We conceived our function to work on numbers:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsqrt_minus_1(3.25)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.5\n```\n\n\n:::\n:::\n\n\n\n\n-   but it actually works on vectors too, as a free bonus of R:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsqrt_minus_1(c(50, 11, 3))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 7.000000 3.162278 1.414214\n```\n\n\n:::\n:::\n\n\n\n\n-   or... (over)\n\n## Vectorization 2/2\n\n-   or even data frames:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd <- tibble(x = 1:2, y = 3:4)\nd\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"x\"],\"name\":[1],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"y\"],\"name\":[2],\"type\":[\"int\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"1\",\"2\":\"3\"},{\"1\":\"2\",\"2\":\"4\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsqrt_minus_1(d)\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"x\"],\"name\":[1],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"y\"],\"name\":[2],\"type\":[\"dbl\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"0\",\"2\":\"1.414214\"},{\"1\":\"1\",\"2\":\"1.732051\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\n\n\n## More than one input\n\n-   Allow the value to be subtracted, before taking square root, to be\n    input to function as well, thus:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsqrt_minus_value <- function(x, d) {\n  sqrt(x - d)\n}\n```\n:::\n\n\n\n\n-   Call the function with the x and d inputs in the right order:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsqrt_minus_value(51, 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 7\n```\n\n\n:::\n:::\n\n\n\n\n-   or give the inputs names, in which case they can be in *any order*:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsqrt_minus_value(d = 2, x = 51)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 7\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nd\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"x\"],\"name\":[1],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"y\"],\"name\":[2],\"type\":[\"int\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"1\",\"2\":\"3\"},{\"1\":\"2\",\"2\":\"4\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n\n```{.r .cell-code}\nd.1 <- lm(y ~ x, data = d)\nsummary(d.1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nCall:\nlm(formula = y ~ x, data = d)\n\nResiduals:\nALL 2 residuals are 0: no residual degrees of freedom!\n\nCoefficients:\n            Estimate Std. Error t value Pr(>|t|)\n(Intercept)        2        NaN     NaN      NaN\nx                  1        NaN     NaN      NaN\n\nResidual standard error: NaN on 0 degrees of freedom\nMultiple R-squared:      1,\tAdjusted R-squared:    NaN \nF-statistic:   NaN on 1 and 0 DF,  p-value: NA\n```\n\n\n:::\n:::\n\n\n\n\n## Defaults 1/2\n\n-   Many R functions have values that you can change if you want to, but\n    usually you don’t want to, for example:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(3, 4, 5, NA, 6, 7)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  3  4  5 NA  6  7\n```\n\n\n:::\n\n```{.r .cell-code}\nmean(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n\n```{.r .cell-code}\nmean(x, na.rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5\n```\n\n\n:::\n:::\n\n\n\n\n-   By default, the mean of data with a missing value is missing, but if\n    you specify `na.rm=TRUE`, the missing values are removed before the\n    mean is calculated.\n\n-   That is, `na.rm` has a default value of `FALSE`: that’s what it will\n    be unless you change it.\n\n## Defaults 2/2\n\n-   In our function, set a default value for d like this:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsqrt_minus_value <- function(x, d = 1) {\n  sqrt(x - d)\n}\n```\n:::\n\n\n\n\n-   If you specify a value for d, it will be used. If you don't, 1 will\n    be used instead:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsqrt_minus_value(51, 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 7\n```\n\n\n:::\n\n```{.r .cell-code}\nsqrt_minus_value(51)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 7.071068\n```\n\n\n:::\n:::\n\n\n\n\n## Catching errors before they happen\n\n-   What happened here?\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsqrt_minus_value(6, 8)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in sqrt(x - d): NaNs produced\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NaN\n```\n\n\n:::\n:::\n\n\n\n\n-   Message not helpful. Actually, function tried to take square root of\n    negative number.\n-   In fact, not even error, just warning.\n-   Check that the square root will be OK first. Here’s how:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsqrt_minus_value <- function(x, d = 1) {\n  stopifnot(x - d >= 0)\n  sqrt(x - d)\n}\n```\n:::\n\n\n\n\n## What happens with `stopifnot`\n\n-   This should be good, and is:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsqrt_minus_value(8, 6)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.414214\n```\n\n\n:::\n:::\n\n\n\n\n-   This should fail, and see how it does:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsqrt_minus_value(6, 8)\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in sqrt_minus_value(6, 8): x - d >= 0 is not TRUE\n```\n\n\n:::\n:::\n\n\n\n\n-   Where the function fails, we get informative error, but if\n    everything good, the `stopifnot` does nothing.\n-   `stopifnot` contains one or more logical conditions, and all of them\n    have to be true for function to work. So put in everything that you\n    want to be true.\n\n## Using R’s built-ins\n\n-   When you write a function, you can use anything built-in to R, or\n    even any functions that you defined before.\n-   For example, if you will be calculating a lot of regression-line\n    slopes, you don’t have to do this from scratch: you can use R’s\n    regression calculations, like this:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_df <- tibble(x = 1:4, y = c(10, 11, 10, 14))\nmy_df\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"x\"],\"name\":[1],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"y\"],\"name\":[2],\"type\":[\"dbl\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"1\",\"2\":\"10\"},{\"1\":\"2\",\"2\":\"11\"},{\"1\":\"3\",\"2\":\"10\"},{\"1\":\"4\",\"2\":\"14\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\n\n\n## Running the regression\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_df.1 <- lm(y ~ x, data = my_df)\ntidy(my_df.1)\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"term\"],\"name\":[1],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"estimate\"],\"name\":[2],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"std.error\"],\"name\":[3],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"statistic\"],\"name\":[4],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"p.value\"],\"name\":[5],\"type\":[\"dbl\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"(Intercept)\",\"2\":\"8.5\",\"3\":\"1.8774983\",\"4\":\"4.527301\",\"5\":\"0.04548594\"},{\"1\":\"x\",\"2\":\"1.1\",\"3\":\"0.6855655\",\"4\":\"1.604515\",\"5\":\"0.24980623\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\n\n\n\n## Pulling out just the slope\n\nUse `pluck`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntidy(my_df.1) %>% pluck(\"estimate\", 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.1\n```\n\n\n:::\n:::\n\n\n\n\n## Making this into a function\n\n-   First step: make sure you have it working without a function (we do)\n-   Inputs: two, an `x` and a `y`.\n-   Output: just the slope, a number. Thus:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nslope <- function(xx, yy) {\n  y.1 <- lm(yy ~ xx)\n  tidy(y.1) %>% pluck(\"estimate\", 2)\n}\n```\n:::\n\n\n\n\n-   Check using our data from before: correct:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwith(my_df, slope(x, y))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.1\n```\n\n\n:::\n:::\n\n\n\n\n## Passing things on\n\n-   `lm` has a lot of options, with defaults, that we might want to\n    change. Instead of intercepting all the possibilities and passing\n    them on, we can do this:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nslope <- function(xx, yy, ...) {\n  y.1 <- lm(yy ~ xx, ...)\n  tidy(y.1) %>% pluck(\"estimate\", 2)\n}\n```\n:::\n\n\n\n\n-   The `...` in the header line means “accept any other input”, and the\n    `...` in the `lm` line means “pass anything other than `x` and `y`\n    straight on to `lm`”.\n\n## Using `...`\n\n-   One of the things `lm` will accept is a vector called `subset`\n    containing the list of observations to include in the regression.\n-   So we should be able to do this:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwith(my_df, slope(x, y, subset = 3:4))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4\n```\n\n\n:::\n:::\n\n\n\n\n-   Just uses the last two observations in `x` and `y`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_df %>% slice(3:4)\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"x\"],\"name\":[1],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"y\"],\"name\":[2],\"type\":[\"dbl\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"3\",\"2\":\"10\"},{\"1\":\"4\",\"2\":\"14\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\n\n\n-   so the slope should be $(14 − 10)/(4 − 3) = 4$ and is.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwith(my_df, slope(x, y, hair = \"spiky\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.1\n```\n\n\n:::\n:::\n\n\n\n\n\n\n## Running a function for each of several inputs\n\n-   Suppose we have a data frame containing several different `x`’s to\n    use in regressions, along with the `y` we had before:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(d <- tibble(x1 = 1:4, x2 = c(8, 7, 6, 5), x3 = c(2, 4, 6, 9)))\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"x1\"],\"name\":[1],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"x2\"],\"name\":[2],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"x3\"],\"name\":[3],\"type\":[\"dbl\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"1\",\"2\":\"8\",\"3\":\"2\"},{\"1\":\"2\",\"2\":\"7\",\"3\":\"4\"},{\"1\":\"3\",\"2\":\"6\",\"3\":\"6\"},{\"1\":\"4\",\"2\":\"5\",\"3\":\"9\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\n\n\n-   Want to use these as different x’s for a regression with `y` from\n    `my_df` as the response, and collect together the three different\n    slopes.\n-   Python-like way: a `for` loop.\n-   R-like way: `map_dbl`: less coding, but more thinking.\n\n## The loop way\n\n-   “Pull out” column `i` of data frame `d` as `d %>% pull(i)`.\n-   Create empty vector `slopes` to store the slopes.\n-   Looping variable `i` goes from 1 to 3 (3 columns, thus 3 slopes):\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nslopes <- numeric(3)\nfor (i in 1:3) {\n  d %>% pull(i) -> xx\n  slopes[i] <- slope(xx, my_df$y)\n}\nslopes\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  1.1000000 -1.1000000  0.5140187\n```\n\n\n:::\n:::\n\n\n\n\n-   Check this by doing the three `lm`s, one at a time.\n\n## The `map_dbl` way\n\n-   In words: for each of these (columns of `d`), run function (`slope`)\n    with inputs \"it\" and `y`), and collect together the answers.\n-   Since slope returns a decimal number (a `dbl`), appropriate\n    function-running function is `map_dbl`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"x1\"],\"name\":[1],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"x2\"],\"name\":[2],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"x3\"],\"name\":[3],\"type\":[\"dbl\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"1\",\"2\":\"8\",\"3\":\"2\"},{\"1\":\"2\",\"2\":\"7\",\"3\":\"4\"},{\"1\":\"3\",\"2\":\"6\",\"3\":\"6\"},{\"1\":\"4\",\"2\":\"5\",\"3\":\"9\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmap_dbl(d, \\(d) slope(d, my_df$y))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n        x1         x2         x3 \n 1.1000000 -1.1000000  0.5140187 \n```\n\n\n:::\n:::\n\n\n\n\n-   Same as loop, with a lot less coding.\n\n## Square roots\n\n-   “Find the square roots of each of the numbers 1 through 10”:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1:10\nmap_dbl(x, \\(x) sqrt(x))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 1.000000 1.414214 1.732051 2.000000 2.236068 2.449490 2.645751 2.828427\n [9] 3.000000 3.162278\n```\n\n\n:::\n:::\n\n\n\n\n## Summarizing all columns of a data frame, two ways\n\n-   use my `d` from above:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap_dbl(d, \\(d) mean(d))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  x1   x2   x3 \n2.50 6.50 5.25 \n```\n\n\n:::\n\n```{.r .cell-code}\nd %>% summarize(across(everything(), \\(x) mean(x)))\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"x1\"],\"name\":[1],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"x2\"],\"name\":[2],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"x3\"],\"name\":[3],\"type\":[\"dbl\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"2.5\",\"2\":\"6.5\",\"3\":\"5.25\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\n\n\nThe mean of each column, with the columns labelled.\n\n## What if summary returns more than one thing?\n\n-   For example, finding quartiles:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nquartiles <- function(x) {\n  quantile(x, c(0.25, 0.75))\n}\nquartiles(1:5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n25% 75% \n  2   4 \n```\n\n\n:::\n:::\n\n\n\n\n-   When function returns more than one thing, `map` (or `map_df`)\n    instead of `map_dbl`.\n\n## map results\n\n-   Try:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"x1\"],\"name\":[1],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"x2\"],\"name\":[2],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"x3\"],\"name\":[3],\"type\":[\"dbl\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"1\",\"2\":\"8\",\"3\":\"2\"},{\"1\":\"2\",\"2\":\"7\",\"3\":\"4\"},{\"1\":\"3\",\"2\":\"6\",\"3\":\"6\"},{\"1\":\"4\",\"2\":\"5\",\"3\":\"9\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nd\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"x1\"],\"name\":[1],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"x2\"],\"name\":[2],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"x3\"],\"name\":[3],\"type\":[\"dbl\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"1\",\"2\":\"8\",\"3\":\"2\"},{\"1\":\"2\",\"2\":\"7\",\"3\":\"4\"},{\"1\":\"3\",\"2\":\"6\",\"3\":\"6\"},{\"1\":\"4\",\"2\":\"5\",\"3\":\"9\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n\n```{.r .cell-code}\nmap(d, \\(d) quartiles(d)) -> e\ne\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$x1\n 25%  75% \n1.75 3.25 \n\n$x2\n 25%  75% \n5.75 7.25 \n\n$x3\n 25%  75% \n3.50 6.75 \n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ne[[3]][2]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n 75% \n6.75 \n```\n\n\n:::\n:::\n\n\n\n\n\n-   A list.\n\n## Or\n\n-   Better: pretend output from quartiles is one-row data frame:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap_df(d, \\(d) quartiles(d))\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"25%\"],\"name\":[1],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"75%\"],\"name\":[2],\"type\":[\"dbl\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"1.75\",\"2\":\"3.25\"},{\"1\":\"5.75\",\"2\":\"7.25\"},{\"1\":\"3.50\",\"2\":\"6.75\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\n\n\n## Or even\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd %>% map_df(\\(d) quartiles(d))\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"25%\"],\"name\":[1],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"75%\"],\"name\":[2],\"type\":[\"dbl\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"1.75\",\"2\":\"3.25\"},{\"1\":\"5.75\",\"2\":\"7.25\"},{\"1\":\"3.50\",\"2\":\"6.75\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\n\n\n## Comments\n\n-   This works because the implicit first thing in map is (the columns\n    of) the data frame that came out of the previous step.\n-   These are 1st and 3rd quartiles of each column of `d`, according to\n    R’s default definition (see help for `quantile`).\n\n## `Map` in data frames with `mutate`\n\n-   `map` can also be used within data frames to calculate new columns.\n    Let’s do the square roots of 1 through 10 again:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd <- tibble(x = 1:10)\nd\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"x\"],\"name\":[1],\"type\":[\"int\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"1\"},{\"1\":\"2\"},{\"1\":\"3\"},{\"1\":\"4\"},{\"1\":\"5\"},{\"1\":\"6\"},{\"1\":\"7\"},{\"1\":\"8\"},{\"1\":\"9\"},{\"1\":\"10\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n\n```{.r .cell-code}\nd %>% mutate(root = map_dbl(x, \\(x) sqrt(x)))\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"x\"],\"name\":[1],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"root\"],\"name\":[2],\"type\":[\"dbl\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"1\",\"2\":\"1.000000\"},{\"1\":\"2\",\"2\":\"1.414214\"},{\"1\":\"3\",\"2\":\"1.732051\"},{\"1\":\"4\",\"2\":\"2.000000\"},{\"1\":\"5\",\"2\":\"2.236068\"},{\"1\":\"6\",\"2\":\"2.449490\"},{\"1\":\"7\",\"2\":\"2.645751\"},{\"1\":\"8\",\"2\":\"2.828427\"},{\"1\":\"9\",\"2\":\"3.000000\"},{\"1\":\"10\",\"2\":\"3.162278\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\n\n\n## Write a function first and then map it\n\n-   If the “for each” part is simple, go ahead and use `map_`-whatever.\n-   If not, write a function to do the complicated thing first.\n-   Example: “half or triple plus one”: if the input is an even number,\n    halve it; if it is an odd number, multiply it by three and add one.\n-   This is hard to do as a one-liner: first we have to figure out\n    whether the input is odd or even, and then we have to do the right\n    thing with it.\n\n## Odd or even?\n\n-   Odd or even? Work out the remainder when dividing by 2:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n6 %% 2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0\n```\n\n\n:::\n\n```{.r .cell-code}\n5 %% 2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n\n```{.r .cell-code}\n# 13 %/% 2\n```\n:::\n\n\n\n\n-   5 has remainder 1 so it is odd.\n\n## Write the function\n\n-   First test for integerness, then test for odd or even, and then do\n    the appropriate calculation:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhotpo <- function(x) {\n  stopifnot(round(x) == x) # passes if input an integer\n  remainder <- x %% 2\n  if (remainder == 1) { # odd number\n    ans <- 3 * x + 1\n  }\n  else { # even number\n    ans <- x %/% 2 # integer division\n  }\n  ans\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 4\nifelse((x %% 2) == 1, 3 * x + 1, x %/% 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n:::\n\n\n\n\n## Test it\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhotpo(3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10\n```\n\n\n:::\n\n```{.r .cell-code}\nhotpo(12)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 6\n```\n\n\n:::\n\n```{.r .cell-code}\nhotpo(4.5)\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in hotpo(4.5): round(x) == x is not TRUE\n```\n\n\n:::\n:::\n\n\n\n\n## One through ten\n\n-   Use a data frame of numbers 1 through 10 again:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# tibble(x = 1:10) %>% mutate(y = hotpo(x))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntibble(x = 1:10) %>% mutate(y = map_int(x, \\(x) hotpo(x)))\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"x\"],\"name\":[1],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"y\"],\"name\":[2],\"type\":[\"int\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"1\",\"2\":\"4\"},{\"1\":\"2\",\"2\":\"1\"},{\"1\":\"3\",\"2\":\"10\"},{\"1\":\"4\",\"2\":\"2\"},{\"1\":\"5\",\"2\":\"16\"},{\"1\":\"6\",\"2\":\"3\"},{\"1\":\"7\",\"2\":\"22\"},{\"1\":\"8\",\"2\":\"4\"},{\"1\":\"9\",\"2\":\"28\"},{\"1\":\"10\",\"2\":\"5\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\n\n\n## Until I get to 1 (if I ever do) {.smaller}\n\n-   If I start from a number, find `hotpo` of it, then find `hotpo` of\n    that, and keep going, what happens?\n-   If I get to 4, 2, 1, 4, 2, 1 I’ll repeat for ever, so let’s stop\n    when we get to 1:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhotpo_seq <- function(x) {\n  ans <- x\n  while (x != 1) {\n    x <- hotpo(x)\n    ans <- c(ans, x)\n  }\n  ans\n}\n```\n:::\n\n\n\n\n-   Strategy: keep looping “while `x` is not 1”.\n-   Each new `x`: add to the end of `ans`. When I hit 1, I break out of\n    the `while` and return the whole `ans`.\n\n## Trying it 1/2\n\n-   Start at 6:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhotpo_seq(6)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  6  3 10  5 16  8  4  2  1\n```\n\n\n:::\n:::\n\n\n\n\n## Trying it 2/2\n\n-   Start at 27:\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\n\\footnotesize\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhotpo_seq(27)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  [1]   27   82   41  124   62   31   94   47  142   71  214\n [12]  107  322  161  484  242  121  364  182   91  274  137\n [23]  412  206  103  310  155  466  233  700  350  175  526\n [34]  263  790  395 1186  593 1780  890  445 1336  668  334\n [45]  167  502  251  754  377 1132  566  283  850  425 1276\n [56]  638  319  958  479 1438  719 2158 1079 3238 1619 4858\n [67] 2429 7288 3644 1822  911 2734 1367 4102 2051 6154 3077\n [78] 9232 4616 2308 1154  577 1732  866  433 1300  650  325\n [89]  976  488  244  122   61  184   92   46   23   70   35\n[100]  106   53  160   80   40   20   10    5   16    8    4\n[111]    2    1\n```\n\n\n:::\n:::\n\n\n\n\n\\normalsize\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\n## Which starting points have the longest sequences?\n\n-   The `length` of the vector returned from `hotpo_seq` says how long\n    it took to get to 1.\n-   Out of the starting points 1 to 100, which one has the longest\n    sequence?\n\n## Top 10 longest sequences\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntibble(start = 1:100) %>%\n  mutate(seq_length = map_int(\n    start, \\(start) length(hotpo_seq(start)))) %>%\n  slice_max(seq_length, n = 10)\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"start\"],\"name\":[1],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"seq_length\"],\"name\":[2],\"type\":[\"int\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"97\",\"2\":\"119\"},{\"1\":\"73\",\"2\":\"116\"},{\"1\":\"54\",\"2\":\"113\"},{\"1\":\"55\",\"2\":\"113\"},{\"1\":\"27\",\"2\":\"112\"},{\"1\":\"82\",\"2\":\"111\"},{\"1\":\"83\",\"2\":\"111\"},{\"1\":\"41\",\"2\":\"110\"},{\"1\":\"62\",\"2\":\"108\"},{\"1\":\"63\",\"2\":\"108\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\n\n\n-   27 is an unusually low starting point to have such a long sequence.\n\n## What happens if we save the entire sequence?\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntibble(start = 1:7) %>%\n  mutate(sequence = map(start, \\(start) hotpo_seq(start)))\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"start\"],\"name\":[1],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"sequence\"],\"name\":[2],\"type\":[\"list\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"1\",\"2\":\"<int [1]>\"},{\"1\":\"2\",\"2\":\"<dbl [2]>\"},{\"1\":\"3\",\"2\":\"<dbl [8]>\"},{\"1\":\"4\",\"2\":\"<dbl [3]>\"},{\"1\":\"5\",\"2\":\"<dbl [6]>\"},{\"1\":\"6\",\"2\":\"<dbl [9]>\"},{\"1\":\"7\",\"2\":\"<dbl [17]>\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\n\n\n-   Each entry in `sequence` is itself a vector. `sequence` is a\n    “list-column”.\n\n## Using the whole sequence to find its length and its max\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntibble(start = 1:7) %>%\n  mutate(sequence = map(start, \\(start) hotpo_seq(start))) %>%\n  mutate(\n    seq_length = map_int(sequence, \\(sequence) length(sequence)),\n    seq_max = map_int(sequence, \\(sequence) max(sequence))\n  )\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"start\"],\"name\":[1],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"sequence\"],\"name\":[2],\"type\":[\"list\"],\"align\":[\"right\"]},{\"label\":[\"seq_length\"],\"name\":[3],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"seq_max\"],\"name\":[4],\"type\":[\"int\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"1\",\"2\":\"<int [1]>\",\"3\":\"1\",\"4\":\"1\"},{\"1\":\"2\",\"2\":\"<dbl [2]>\",\"3\":\"2\",\"4\":\"2\"},{\"1\":\"3\",\"2\":\"<dbl [8]>\",\"3\":\"8\",\"4\":\"16\"},{\"1\":\"4\",\"2\":\"<dbl [3]>\",\"3\":\"3\",\"4\":\"4\"},{\"1\":\"5\",\"2\":\"<dbl [6]>\",\"3\":\"6\",\"4\":\"16\"},{\"1\":\"6\",\"2\":\"<dbl [9]>\",\"3\":\"9\",\"4\":\"16\"},{\"1\":\"7\",\"2\":\"<dbl [17]>\",\"3\":\"17\",\"4\":\"52\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\n\n\n## Does it work with `rowwise`?\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntibble(start=1:7) %>% \n  rowwise() %>% \n  mutate(sequence = 0) %>% \n  mutate(seq_length = length(sequence)) %>% \n  mutate(seq_max = max(sequence))\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"start\"],\"name\":[1],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"sequence\"],\"name\":[2],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"seq_length\"],\"name\":[3],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"seq_max\"],\"name\":[4],\"type\":[\"dbl\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"1\",\"2\":\"0\",\"3\":\"1\",\"4\":\"0\"},{\"1\":\"2\",\"2\":\"0\",\"3\":\"1\",\"4\":\"0\"},{\"1\":\"3\",\"2\":\"0\",\"3\":\"1\",\"4\":\"0\"},{\"1\":\"4\",\"2\":\"0\",\"3\":\"1\",\"4\":\"0\"},{\"1\":\"5\",\"2\":\"0\",\"3\":\"1\",\"4\":\"0\"},{\"1\":\"6\",\"2\":\"0\",\"3\":\"1\",\"4\":\"0\"},{\"1\":\"7\",\"2\":\"0\",\"3\":\"1\",\"4\":\"0\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\n\n\nIt does.\n\n## Final thoughts on this\n\n-   Called the **Collatz conjecture**.\n-   Nobody knows whether the sequence always gets to 1.\n-   Nobody has found an $n$ for which it doesn’t.\n-   A [tree](https://www.jasondavies.com/collatz-graph/).\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<link href=\"functions_files/libs/pagedtable-1.1/css/pagedtable.css\" rel=\"stylesheet\" />\n<script src=\"functions_files/libs/pagedtable-1.1/js/pagedtable.js\"></script>\n"
      ],
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}