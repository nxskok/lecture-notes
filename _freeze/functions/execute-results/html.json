{
  "hash": "85a3c227148dfefa4d5d86603ab0f099",
  "result": {
    "markdown": "---\ntitle: \"Functions\"\n---\n\n\n## Packages for this section\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(broom)\n```\n:::\n\n\n\n## Don’t repeat yourself\n- See this:\n\n::: {.cell}\n\n```{.r .cell-code}\na <- 50\nb <- 11\nd <- 3\nas <- sqrt(a - 1)\nas\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 7\n```\n:::\n\n```{.r .cell-code}\nbs <- sqrt(b - 1)\nbs\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3.162278\n```\n:::\n\n```{.r .cell-code}\nds <- sqrt(d - 1)\nds\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1.414214\n```\n:::\n:::\n\n\n\n## What's the problem?\n\n- Same calculation done three different times, by copying, pasting and\nediting.\n- Dangerous: what if you forget to change something after you pasted?\n\n- Programming principle: \"don't repeat yourself\".\n- Hadley Wickham: don't copy-paste more than twice.\n- Instead: *write a function*. \n\n## Anatomy of function\n- Header line with function name and input value(s).\n- Body with calculation of values to output/return.\n- Return value: the output from function.\nIn our case:\n\n::: {.cell}\n\n```{.r .cell-code}\nsqrt_minus_1 <- function(x) {\n  ans <- sqrt(x - 1)\n  return(ans)\n}\n```\n:::\n\n\nor more simply (\"the R way\", better style)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsqrt_minus_1 <- function(x) {\n  sqrt(x - 1)\n}\n```\n:::\n\n\nIf last line of function calculates value without saving it, that value is\nreturned.\n\n## About the input; testing\n- The input to a function can be called anything. Here we called it `x`.\nThis is the name used inside the function.\n- The function is a “machine” for calculating square-root-minus-1. It\ndoesn’t do anything until you call it:\n\n::: {.cell}\n\n```{.r .cell-code}\nsqrt_minus_1(50)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 7\n```\n:::\n\n```{.r .cell-code}\nsqrt_minus_1(11)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3.162278\n```\n:::\n\n```{.r .cell-code}\nsqrt_minus_1(3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1.414214\n```\n:::\n:::\n\n\n- It works!\n\n## Vectorization 1/2 \n\n- We conceived our function to work on numbers:\n\n::: {.cell}\n\n```{.r .cell-code}\nsqrt_minus_1(3.25)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1.5\n```\n:::\n:::\n\n\n- but it actually works on vectors too, as a free bonus of R:\n\n::: {.cell}\n\n```{.r .cell-code}\nsqrt_minus_1(c(50, 11, 3))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 7.000000 3.162278 1.414214\n```\n:::\n:::\n\n\n- or... (over)\n\n## Vectorization 2/2 \n\n- or even data frames:\n\n::: {.cell}\n\n```{.r .cell-code}\nd <- tibble(x = 1:2, y = 3:4)\nsqrt_minus_1(d)\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"x\"],\"name\":[1],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"y\"],\"name\":[2],\"type\":[\"dbl\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"0\",\"2\":\"1.414214\"},{\"1\":\"1\",\"2\":\"1.732051\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\n## More than one input\n\n- Allow the value to be subtracted, before taking square root, to be\ninput to function as well, thus:\n\n::: {.cell}\n\n```{.r .cell-code}\nsqrt_minus_value <- function(x, d) {\n  sqrt(x - d)\n}\n```\n:::\n\n\n- Call the function with the x and d inputs in the right order:\n\n::: {.cell}\n\n```{.r .cell-code}\nsqrt_minus_value(51, 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 7\n```\n:::\n:::\n\n\n- or give the inputs names, in which case they can be in *any order*:\n\n::: {.cell}\n\n```{.r .cell-code}\nsqrt_minus_value(d = 2, x = 51)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 7\n```\n:::\n:::\n\n\n## Defaults 1/2\n- Many R functions have values that you can change if you want to,\nbut usually you don’t want to, for example:\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(3, 4, 5, NA, 6, 7)\nmean(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NA\n```\n:::\n\n```{.r .cell-code}\nmean(x, na.rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5\n```\n:::\n:::\n\n\n- By default, the mean of data with a missing value is missing, but if\nyou specify `na.rm=TRUE`, the missing values are removed before the mean\nis calculated.\n\n- That is, `na.rm` has a default value of `FALSE`: that’s what it will be unless\nyou change it.\n\n## Defaults 2/2\n- In our function, set a default value for d like this:\n\n::: {.cell}\n\n```{.r .cell-code}\nsqrt_minus_value <- function(x, d = 1) {\n  sqrt(x - d)\n}\n```\n:::\n\n\n- If you specify a value for d, it will be used. If you don't, 1 will be used instead: \n\n\n::: {.cell}\n\n```{.r .cell-code}\nsqrt_minus_value(51, 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 7\n```\n:::\n\n```{.r .cell-code}\nsqrt_minus_value(51)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 7.071068\n```\n:::\n:::\n\n\n## Catching errors before they happen\n- What happened here?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsqrt_minus_value(6, 8)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in sqrt(x - d): NaNs produced\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NaN\n```\n:::\n:::\n\n\n- Message not helpful. Actually, function tried to take square root of\nnegative number.\n- In fact, not even error, just warning.\n- Check that the square root will be OK first. Here’s how:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsqrt_minus_value <- function(x, d = 1) {\n  stopifnot(x - d >= 0)\n  sqrt(x - d)\n}\n```\n:::\n\n\n## What happens with `stopifnot`\n- This should be good, and is:\n\n::: {.cell}\n\n```{.r .cell-code}\nsqrt_minus_value(8, 6)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1.414214\n```\n:::\n:::\n\n\n- This should fail, and see how it does:\n\n::: {.cell}\n\n```{.r .cell-code}\nsqrt_minus_value(6, 8)\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in sqrt_minus_value(6, 8): x - d >= 0 is not TRUE\n```\n:::\n:::\n\n\n- Where the function fails, we get informative error, but if everything\ngood, the `stopifnot` does nothing.\n- `stopifnot` contains one or more logical conditions, and all of them\nhave to be true for function to work. So put in everything that you\nwant to be true.\n\n## Using R’s built-ins\n- When you write a function, you can use anything built-in to R, or\neven any functions that you defined before.\n- For example, if you will be calculating a lot of regression-line slopes,\nyou don’t have to do this from scratch: you can use R’s regression\ncalculations, like this:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_df <- tibble(x = 1:4, y = c(10, 11, 10, 14))\n# my_df\nmy_df.1 <- lm(y ~ x, data = my_df)\n# summary(my_df.1)\ntidy(my_df.1)\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"term\"],\"name\":[1],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"estimate\"],\"name\":[2],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"std.error\"],\"name\":[3],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"statistic\"],\"name\":[4],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"p.value\"],\"name\":[5],\"type\":[\"dbl\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"(Intercept)\",\"2\":\"8.5\",\"3\":\"1.8774983\",\"4\":\"4.527301\",\"5\":\"0.04548594\"},{\"1\":\"x\",\"2\":\"1.1\",\"3\":\"0.6855655\",\"4\":\"1.604515\",\"5\":\"0.24980623\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\n## Pulling out just the slope\n\nUse `pluck`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntidy(my_df.1) %>% pluck(\"estimate\", 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1.1\n```\n:::\n:::\n\n\n\n## Making this into a function\n- First step: make sure you have it working without a function (we do)\n- Inputs: two, an `x` and a `y`.\n- Output: just the slope, a number. Thus:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nslope <- function(xx, yy) {\n  y.1 <- lm(yy ~ xx)\n  tidy(y.1) %>% pluck(\"estimate\", 2)\n}\n```\n:::\n\n\n- Check using our data from before: correct:\n\n::: {.cell}\n\n```{.r .cell-code}\nwith(my_df, slope(x, y))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1.1\n```\n:::\n:::\n\n\n## Passing things on\n- `lm` has a lot of options, with defaults, that we might want to change.\nInstead of intercepting all the possibilities and passing them on, we\ncan do this:\n\n::: {.cell}\n\n```{.r .cell-code}\nslope <- function(xx, yy, ...) {\n  y.1 <- lm(yy ~ xx, ...)\n  tidy(y.1) %>% pluck(\"estimate\", 2)\n}\n```\n:::\n\n\n- The `...` in the header line means “accept any other input”, and the\n`...` in the `lm` line means “pass anything other than `x` and `y` straight\non to `lm`”.\n\n\n## Using `...`\n- One of the things `lm` will accept is a vector called `subset` containing\nthe list of observations to include in the regression.\n- So we should be able to do this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwith(my_df, slope(x, y, subset = 3:4))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4\n```\n:::\n:::\n\n\n\n- Just uses the last two observations in `x` and `y`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_df %>% slice(3:4)\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"x\"],\"name\":[1],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"y\"],\"name\":[2],\"type\":[\"dbl\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"3\",\"2\":\"10\"},{\"1\":\"4\",\"2\":\"14\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\n\n- so the slope should\nbe $(14 − 10)/(4 − 3) = 4$ and is.\n\n\n\n## Running a function for each of several inputs\n- Suppose we have a data frame containing several different `x`’s to use\nin regressions, along with the `y` we had before:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(d <- tibble(x1 = 1:4, x2 = c(8, 7, 6, 5), x3 = c(2, 4, 6, 9)))\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"x1\"],\"name\":[1],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"x2\"],\"name\":[2],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"x3\"],\"name\":[3],\"type\":[\"dbl\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"1\",\"2\":\"8\",\"3\":\"2\"},{\"1\":\"2\",\"2\":\"7\",\"3\":\"4\"},{\"1\":\"3\",\"2\":\"6\",\"3\":\"6\"},{\"1\":\"4\",\"2\":\"5\",\"3\":\"9\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\n- Want to use these as different x’s for a regression with `y` from `my_df` as the\nresponse, and collect together the three different slopes.\n- Python-like way: a `for` loop.\n- R-like way: `map_dbl`: less coding, but more thinking.\n\n## The loop way\n- “Pull out” column `i` of data frame `d` as `d %>% pull(i)`.\n- Create empty vector `slopes` to store the slopes.\n- Looping variable `i` goes from 1 to 3 (3 columns, thus 3 slopes):\n\n::: {.cell}\n\n```{.r .cell-code}\nslopes <- numeric(3)\nfor (i in 1:3) {\n  d %>% pull(i) -> xx\n  slopes[i] <- slope(xx, my_df$y)\n}\nslopes\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  1.1000000 -1.1000000  0.5140187\n```\n:::\n:::\n\n\n- Check this by doing the three `lm`s, one at a time.\n\n## The `map_dbl` way\n- In words: for each of these (columns of `d`), run function (`slope`) with inputs\n\"it\" and `y`), and collect together the answers.\n- Since slope returns a decimal number (a `dbl`), appropriate\nfunction-running function is `map_dbl`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap_dbl(d, \\(d) slope(d, my_df$y))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        x1         x2         x3 \n 1.1000000 -1.1000000  0.5140187 \n```\n:::\n:::\n\n\n- Same as loop, with a lot less coding.\n\n## Square roots\n\n- “Find the square roots of each of the numbers 1 through 10”:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1:10\nmap_dbl(x, \\(x) sqrt(x))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 1.000000 1.414214 1.732051 2.000000 2.236068 2.449490 2.645751 2.828427\n [9] 3.000000 3.162278\n```\n:::\n:::\n\n\n## Summarizing all columns of a data frame, two ways\n\n- use my `d` from above: \n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap_dbl(d, \\(d) mean(d))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  x1   x2   x3 \n2.50 6.50 5.25 \n```\n:::\n\n```{.r .cell-code}\nd %>% summarize(across(everything(), \\(x) mean(x)))\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"x1\"],\"name\":[1],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"x2\"],\"name\":[2],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"x3\"],\"name\":[3],\"type\":[\"dbl\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"2.5\",\"2\":\"6.5\",\"3\":\"5.25\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\nThe mean of each column, with the columns labelled. \n\n## What if summary returns more than one thing?\n- For example, finding quartiles:\n\n::: {.cell}\n\n```{.r .cell-code}\nquartiles <- function(x) {\n  quantile(x, c(0.25, 0.75))\n}\nquartiles(1:5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n25% 75% \n  2   4 \n```\n:::\n:::\n\n\n- When function returns more than one thing, `map` (or `map_df`) instead\nof `map_dbl`.\n\n## map results\n- Try:\n\n::: {.cell}\n\n```{.r .cell-code}\nmap(d, \\(d) quartiles(d))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$x1\n 25%  75% \n1.75 3.25 \n\n$x2\n 25%  75% \n5.75 7.25 \n\n$x3\n 25%  75% \n3.50 6.75 \n```\n:::\n:::\n\n\n- A list. \n\n## Or\n\n- Better: pretend output from quartiles is one-column data\nframe: \n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap_df(d, \\(d) quartiles(d))\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"25%\"],\"name\":[1],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"75%\"],\"name\":[2],\"type\":[\"dbl\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"1.75\",\"2\":\"3.25\"},{\"1\":\"5.75\",\"2\":\"7.25\"},{\"1\":\"3.50\",\"2\":\"6.75\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\n## Or even\n\n::: {.cell}\n\n```{.r .cell-code}\nd %>% map_df(\\(d) quartiles(d))\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"25%\"],\"name\":[1],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"75%\"],\"name\":[2],\"type\":[\"dbl\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"1.75\",\"2\":\"3.25\"},{\"1\":\"5.75\",\"2\":\"7.25\"},{\"1\":\"3.50\",\"2\":\"6.75\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\n## Comments\n\n- This works because the implicit first thing in map is (the columns of) the\ndata frame that came out of the previous step.\n- These are 1st and 3rd quartiles of each column of `d`, according to R’s\ndefault definition (see help for `quantile`).\n\n## `Map` in data frames with `mutate`\n- `map` can also be used within data frames to calculate new columns.\nLet’s do the square roots of 1 through 10 again:\n\n::: {.cell}\n\n```{.r .cell-code}\nd <- tibble(x = 1:10)\nd %>% mutate(root = map_dbl(x, \\(x) sqrt(x)))\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"x\"],\"name\":[1],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"root\"],\"name\":[2],\"type\":[\"dbl\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"1\",\"2\":\"1.000000\"},{\"1\":\"2\",\"2\":\"1.414214\"},{\"1\":\"3\",\"2\":\"1.732051\"},{\"1\":\"4\",\"2\":\"2.000000\"},{\"1\":\"5\",\"2\":\"2.236068\"},{\"1\":\"6\",\"2\":\"2.449490\"},{\"1\":\"7\",\"2\":\"2.645751\"},{\"1\":\"8\",\"2\":\"2.828427\"},{\"1\":\"9\",\"2\":\"3.000000\"},{\"1\":\"10\",\"2\":\"3.162278\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\n## Write a function first and then map it\n- If the “for each” part is simple, go ahead and use `map_`-whatever.\n- If not, write a function to do the complicated thing first.\n- Example: “half or triple plus one”: if the input is an even number,\nhalve it; if it is an odd number, multiply it by three and add one.\n- This is hard to do as a one-liner: first we have to figure out whether\nthe input is odd or even, and then we have to do the right thing with\nit.\n\n## Odd or even?\n\n\n- Odd or even? Work out the remainder when dividing by 2:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n6 %% 2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0\n```\n:::\n\n```{.r .cell-code}\n5 %% 2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n:::\n\n\n- 5 has remainder 1 so it is odd.\n\n## Write the function\n- First test for integerness, then test for odd or even, and then do the appropriate calculation:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhotpo <- function(x) {\n  stopifnot(round(x) == x) # passes if input an integer\n  remainder <- x %% 2\n  if (remainder == 1) {\n    ans <- 3 * x + 1\n  }\n  else {\n    ans <- x %/% 2 # integer division\n  }\n  ans\n}\n```\n:::\n\n\n## Test it \n\n\n::: {.cell}\n\n```{.r .cell-code}\nhotpo(3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 10\n```\n:::\n\n```{.r .cell-code}\nhotpo(12)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 6\n```\n:::\n\n```{.r .cell-code}\nhotpo(4.5)\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in hotpo(4.5): round(x) == x is not TRUE\n```\n:::\n:::\n\n\n\n## One through ten\n- Use a data frame of numbers 1 through 10 again:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntibble(x = 1:10) %>% mutate(y = map_int(x, \\(x) hotpo(x)))\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"x\"],\"name\":[1],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"y\"],\"name\":[2],\"type\":[\"int\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"1\",\"2\":\"4\"},{\"1\":\"2\",\"2\":\"1\"},{\"1\":\"3\",\"2\":\"10\"},{\"1\":\"4\",\"2\":\"2\"},{\"1\":\"5\",\"2\":\"16\"},{\"1\":\"6\",\"2\":\"3\"},{\"1\":\"7\",\"2\":\"22\"},{\"1\":\"8\",\"2\":\"4\"},{\"1\":\"9\",\"2\":\"28\"},{\"1\":\"10\",\"2\":\"5\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\n## Until I get to 1 (if I ever do) {.smaller}\n- If I start from a number, find `hotpo` of it, then find `hotpo` of that,\nand keep going, what happens?\n- If I get to 4, 2, 1, 4, 2, 1 I’ll repeat for ever, so let’s stop when we get\nto 1:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhotpo_seq <- function(x) {\n  ans <- x\n  while (x != 1) {\n    x <- hotpo(x)\n    ans <- c(ans, x)\n  }\n  ans\n}\n```\n:::\n\n\n- Strategy: keep looping “while `x` is not 1”.\n- Each new `x`: add to the end of `ans`. When I hit 1, I break\nout of the `while` and return the whole `ans`. \n\n## Trying it 1/2\n- Start at 6:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhotpo_seq(6)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  6  3 10  5 16  8  4  2  1\n```\n:::\n:::\n\n\n## Trying it 2/2 \n\n- Start at 27:\n\n\n::: {.cell}\n\n:::\n\n\n\n\\footnotesize\n\n::: {.cell}\n\n```{.r .cell-code}\nhotpo_seq(27)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  [1]   27   82   41  124   62   31   94   47  142   71  214\n [12]  107  322  161  484  242  121  364  182   91  274  137\n [23]  412  206  103  310  155  466  233  700  350  175  526\n [34]  263  790  395 1186  593 1780  890  445 1336  668  334\n [45]  167  502  251  754  377 1132  566  283  850  425 1276\n [56]  638  319  958  479 1438  719 2158 1079 3238 1619 4858\n [67] 2429 7288 3644 1822  911 2734 1367 4102 2051 6154 3077\n [78] 9232 4616 2308 1154  577 1732  866  433 1300  650  325\n [89]  976  488  244  122   61  184   92   46   23   70   35\n[100]  106   53  160   80   40   20   10    5   16    8    4\n[111]    2    1\n```\n:::\n:::\n\n\\normalsize\n\n\n::: {.cell}\n\n:::\n\n\n\n## Which starting points have the longest sequences?\n- The `length` of the vector returned from `hotpo_seq` says how long it\ntook to get to 1.\n- Out of the starting points 1 to 100, which one has the longest\nsequence?\n\n## Top 10 longest sequences\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntibble(start = 1:100) %>%\n  mutate(seq_length = map_int(\n    start, \\(start) length(hotpo_seq(start)))) %>%\n  slice_max(seq_length, n = 10)\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"start\"],\"name\":[1],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"seq_length\"],\"name\":[2],\"type\":[\"int\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"97\",\"2\":\"119\"},{\"1\":\"73\",\"2\":\"116\"},{\"1\":\"54\",\"2\":\"113\"},{\"1\":\"55\",\"2\":\"113\"},{\"1\":\"27\",\"2\":\"112\"},{\"1\":\"82\",\"2\":\"111\"},{\"1\":\"83\",\"2\":\"111\"},{\"1\":\"41\",\"2\":\"110\"},{\"1\":\"62\",\"2\":\"108\"},{\"1\":\"63\",\"2\":\"108\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\n- 27 is an unusually low starting point to have such a long sequence.\n\n## What happens if we save the entire sequence? \n\n\n::: {.cell}\n\n```{.r .cell-code}\ntibble(start = 1:7) %>%\n  mutate(sequence = map(start, \\(start) hotpo_seq(start)))\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"start\"],\"name\":[1],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"sequence\"],\"name\":[2],\"type\":[\"list\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"1\",\"2\":\"<int [1]>\"},{\"1\":\"2\",\"2\":\"<dbl [2]>\"},{\"1\":\"3\",\"2\":\"<dbl [8]>\"},{\"1\":\"4\",\"2\":\"<dbl [3]>\"},{\"1\":\"5\",\"2\":\"<dbl [6]>\"},{\"1\":\"6\",\"2\":\"<dbl [9]>\"},{\"1\":\"7\",\"2\":\"<dbl [17]>\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\n\n- Each entry in `sequence` is itself a vector. `sequence` is a\n“list-column”.\n\n## Using the whole sequence to find its length and its max \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntibble(start = 1:7) %>%\n  mutate(sequence = map(start, \\(start) hotpo_seq(start))) %>%\n  mutate(\n    seq_length = map_int(sequence, \\(sequence) length(sequence)),\n    seq_max = map_int(sequence, \\(sequence) max(sequence))\n  )\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"start\"],\"name\":[1],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"sequence\"],\"name\":[2],\"type\":[\"list\"],\"align\":[\"right\"]},{\"label\":[\"seq_length\"],\"name\":[3],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"seq_max\"],\"name\":[4],\"type\":[\"int\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"1\",\"2\":\"<int [1]>\",\"3\":\"1\",\"4\":\"1\"},{\"1\":\"2\",\"2\":\"<dbl [2]>\",\"3\":\"2\",\"4\":\"2\"},{\"1\":\"3\",\"2\":\"<dbl [8]>\",\"3\":\"8\",\"4\":\"16\"},{\"1\":\"4\",\"2\":\"<dbl [3]>\",\"3\":\"3\",\"4\":\"4\"},{\"1\":\"5\",\"2\":\"<dbl [6]>\",\"3\":\"6\",\"4\":\"16\"},{\"1\":\"6\",\"2\":\"<dbl [9]>\",\"3\":\"9\",\"4\":\"16\"},{\"1\":\"7\",\"2\":\"<dbl [17]>\",\"3\":\"17\",\"4\":\"52\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\n\n\n## Does it work with `rowwise`?\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntibble(start=1:7) %>% \n  rowwise() %>% \n  mutate(sequence = list(hotpo_seq(start))) %>% \n  mutate(seq_length = length(sequence)) %>% \n  mutate(seq_max = max(sequence))\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"start\"],\"name\":[1],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"sequence\"],\"name\":[2],\"type\":[\"list\"],\"align\":[\"right\"]},{\"label\":[\"seq_length\"],\"name\":[3],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"seq_max\"],\"name\":[4],\"type\":[\"dbl\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"1\",\"2\":\"<int [1]>\",\"3\":\"1\",\"4\":\"1\"},{\"1\":\"2\",\"2\":\"<dbl [2]>\",\"3\":\"2\",\"4\":\"2\"},{\"1\":\"3\",\"2\":\"<dbl [8]>\",\"3\":\"8\",\"4\":\"16\"},{\"1\":\"4\",\"2\":\"<dbl [3]>\",\"3\":\"3\",\"4\":\"4\"},{\"1\":\"5\",\"2\":\"<dbl [6]>\",\"3\":\"6\",\"4\":\"16\"},{\"1\":\"6\",\"2\":\"<dbl [9]>\",\"3\":\"9\",\"4\":\"16\"},{\"1\":\"7\",\"2\":\"<dbl [17]>\",\"3\":\"17\",\"4\":\"52\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\nIt does.\n\n## Final thoughts on this\n- Called the **Collatz conjecture**.\n- Nobody knows whether the sequence always gets to 1.\n- Nobody has found an $n$ for which it doesn’t.\n- A [tree](https://www.jasondavies.com/collatz-graph/).\n",
    "supporting": [
      "functions_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<link href=\"functions_files/libs/pagedtable-1.1/css/pagedtable.css\" rel=\"stylesheet\" />\n<script src=\"functions_files/libs/pagedtable-1.1/js/pagedtable.js\"></script>\n"
      ],
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}