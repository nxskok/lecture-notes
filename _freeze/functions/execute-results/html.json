{
  "hash": "85a3c227148dfefa4d5d86603ab0f099",
  "result": {
    "markdown": "---\ntitle: \"Functions\"\n---\n\n\n## Packages for this section\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.2     ✔ readr     2.1.4\n✔ forcats   0.5.0     ✔ stringr   1.5.0\n✔ ggplot2   3.4.2     ✔ tibble    3.2.1\n✔ lubridate 1.9.2     ✔ tidyr     1.3.0\n✔ purrr     1.0.1     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n:::\n\n```{.r .cell-code}\nlibrary(broom)\n```\n:::\n\n\n\n## Don’t repeat yourself\n- See this:\n\n::: {.cell}\n\n```{.r .cell-code}\na <- 50\nb <- 11\nd <- 3\nas <- sqrt(a - 1)\nas\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 7\n```\n:::\n\n```{.r .cell-code}\nbs <- sqrt(b - 1)\nbs\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3.162278\n```\n:::\n\n```{.r .cell-code}\nds <- sqrt(d - 1)\nds\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1.414214\n```\n:::\n:::\n\n\n\n## What's the problem?\n\n- Same calculation done three different times, by copying, pasting and\nediting.\n- Dangerous: what if you forget to change something after you pasted?\n\n- Programming principle: \"don't repeat yourself\".\n- Hadley Wickham: don't copy-paste more than twice.\n- Instead: *write a function*. \n\n## Anatomy of function\n- Header line with function name and input value(s).\n- Body with calculation of values to output/return.\n- Return value: the output from function.\nIn our case:\n\n::: {.cell}\n\n```{.r .cell-code}\nsqrt_minus_1 <- function(x) {\n  ans <- sqrt(x - 1)\n  return(ans)\n}\n```\n:::\n\n\nor more simply (\"the R way\", better style)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsqrt_minus_1 <- function(x) {\n  sqrt(x - 1)\n}\n```\n:::\n\n\nIf last line of function calculates value without saving it, that value is\nreturned.\n\n## About the input; testing\n- The input to a function can be called anything. Here we called it `x`.\nThis is the name used inside the function.\n- The function is a “machine” for calculating square-root-minus-1. It\ndoesn’t do anything until you call it:\n\n::: {.cell}\n\n```{.r .cell-code}\nsqrt_minus_1(50)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 7\n```\n:::\n\n```{.r .cell-code}\nsqrt_minus_1(11)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3.162278\n```\n:::\n\n```{.r .cell-code}\nsqrt_minus_1(3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1.414214\n```\n:::\n:::\n\n\n- It works!\n\n## Vectorization 1/2 \n\n- We conceived our function to work on numbers:\n\n::: {.cell}\n\n```{.r .cell-code}\nsqrt_minus_1(3.25)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1.5\n```\n:::\n:::\n\n\n- but it actually works on vectors too, as a free bonus of R:\n\n::: {.cell}\n\n```{.r .cell-code}\nsqrt_minus_1(c(50, 11, 3))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 7.000000 3.162278 1.414214\n```\n:::\n:::\n\n\n- or... (over)\n\n## Vectorization 2/2 \n\n- or even data frames:\n\n::: {.cell}\n\n```{.r .cell-code}\nd <- tibble(x = 1:2, y = 3:4)\nsqrt_minus_1(d)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  x        y\n1 0 1.414214\n2 1 1.732051\n```\n:::\n:::\n\n\n## More than one input\n\n- Allow the value to be subtracted, before taking square root, to be\ninput to function as well, thus:\n\n::: {.cell}\n\n```{.r .cell-code}\nsqrt_minus_value <- function(x, d) {\n  sqrt(x - d)\n}\n```\n:::\n\n\n- Call the function with the x and d inputs in the right order:\n\n::: {.cell}\n\n```{.r .cell-code}\nsqrt_minus_value(51, 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 7\n```\n:::\n:::\n\n\n- or give the inputs names, in which case they can be in *any order*:\n\n::: {.cell}\n\n```{.r .cell-code}\nsqrt_minus_value(d = 2, x = 51)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 7\n```\n:::\n:::\n\n\n## Defaults 1/2\n- Many R functions have values that you can change if you want to,\nbut usually you don’t want to, for example:\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(3, 4, 5, NA, 6, 7)\nmean(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NA\n```\n:::\n\n```{.r .cell-code}\nmean(x, na.rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5\n```\n:::\n:::\n\n\n- By default, the mean of data with a missing value is missing, but if\nyou specify `na.rm=TRUE`, the missing values are removed before the mean\nis calculated.\n\n- That is, `na.rm` has a default value of `FALSE`: that’s what it will be unless\nyou change it.\n\n## Defaults 2/2\n- In our function, set a default value for d like this:\n\n::: {.cell}\n\n```{.r .cell-code}\nsqrt_minus_value <- function(x, d = 1) {\n  sqrt(x - d)\n}\n```\n:::\n\n\n- If you specify a value for d, it will be used. If you don't, 1 will be used instead: \n\n\n::: {.cell}\n\n```{.r .cell-code}\nsqrt_minus_value(51, 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 7\n```\n:::\n\n```{.r .cell-code}\nsqrt_minus_value(51)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 7.071068\n```\n:::\n:::\n\n\n## Catching errors before they happen\n- What happened here?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsqrt_minus_value(6, 8)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in sqrt(x - d): NaNs produced\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NaN\n```\n:::\n:::\n\n\n- Message not helpful. Actually, function tried to take square root of\nnegative number.\n- In fact, not even error, just warning.\n- Check that the square root will be OK first. Here’s how:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsqrt_minus_value <- function(x, d = 1) {\n  stopifnot(x - d >= 0)\n  sqrt(x - d)\n}\n```\n:::\n\n\n## What happens with `stopifnot`\n- This should be good, and is:\n\n::: {.cell}\n\n```{.r .cell-code}\nsqrt_minus_value(8, 6)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1.414214\n```\n:::\n:::\n\n\n- This should fail, and see how it does:\n\n::: {.cell}\n\n```{.r .cell-code}\nsqrt_minus_value(6, 8)\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in sqrt_minus_value(6, 8): x - d >= 0 is not TRUE\n```\n:::\n:::\n\n\n- Where the function fails, we get informative error, but if everything\ngood, the `stopifnot` does nothing.\n- `stopifnot` contains one or more logical conditions, and all of them\nhave to be true for function to work. So put in everything that you\nwant to be true.\n\n## Using R’s built-ins\n- When you write a function, you can use anything built-in to R, or\neven any functions that you defined before.\n- For example, if you will be calculating a lot of regression-line slopes,\nyou don’t have to do this from scratch: you can use R’s regression\ncalculations, like this:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_df <- tibble(x = 1:4, y = c(10, 11, 10, 14))\n# my_df\nmy_df.1 <- lm(y ~ x, data = my_df)\n# summary(my_df.1)\ntidy(my_df.1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 5\n  term        estimate std.error statistic p.value\n  <chr>          <dbl>     <dbl>     <dbl>   <dbl>\n1 (Intercept)      8.5     1.88       4.53  0.0455\n2 x                1.1     0.686      1.60  0.250 \n```\n:::\n:::\n\n\n## Pulling out just the slope\n\nUse `pluck`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntidy(my_df.1) %>% pluck(\"estimate\", 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1.1\n```\n:::\n:::\n\n\n\n## Making this into a function\n- First step: make sure you have it working without a function (we do)\n- Inputs: two, an `x` and a `y`.\n- Output: just the slope, a number. Thus:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nslope <- function(xx, yy) {\n  y.1 <- lm(yy ~ xx)\n  tidy(y.1) %>% pluck(\"estimate\", 2)\n}\n```\n:::\n\n\n- Check using our data from before: correct:\n\n::: {.cell}\n\n```{.r .cell-code}\nwith(my_df, slope(x, y))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1.1\n```\n:::\n:::\n\n\n## Passing things on\n- `lm` has a lot of options, with defaults, that we might want to change.\nInstead of intercepting all the possibilities and passing them on, we\ncan do this:\n\n::: {.cell}\n\n```{.r .cell-code}\nslope <- function(xx, yy, ...) {\n  y.1 <- lm(yy ~ xx, ...)\n  tidy(y.1) %>% pluck(\"estimate\", 2)\n}\n```\n:::\n\n\n- The `...` in the header line means “accept any other input”, and the\n`...` in the `lm` line means “pass anything other than `x` and `y` straight\non to `lm`”.\n\n\n## Using `...`\n- One of the things `lm` will accept is a vector called `subset` containing\nthe list of observations to include in the regression.\n- So we should be able to do this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwith(my_df, slope(x, y, subset = 3:4))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4\n```\n:::\n:::\n\n\n\n- Just uses the last two observations in `x` and `y`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_df %>% slice(3:4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 2\n      x     y\n  <int> <dbl>\n1     3    10\n2     4    14\n```\n:::\n:::\n\n\n\n- so the slope should\nbe $(14 − 10)/(4 − 3) = 4$ and is.\n\n\n\n## Running a function for each of several inputs\n- Suppose we have a data frame containing several different `x`’s to use\nin regressions, along with the `y` we had before:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(d <- tibble(x1 = 1:4, x2 = c(8, 7, 6, 5), x3 = c(2, 4, 6, 9)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 3\n     x1    x2    x3\n  <int> <dbl> <dbl>\n1     1     8     2\n2     2     7     4\n3     3     6     6\n4     4     5     9\n```\n:::\n:::\n\n\n- Want to use these as different x’s for a regression with `y` from `my_df` as the\nresponse, and collect together the three different slopes.\n- Python-like way: a `for` loop.\n- R-like way: `map_dbl`: less coding, but more thinking.\n\n## The loop way\n- “Pull out” column `i` of data frame `d` as `d %>% pull(i)`.\n- Create empty vector `slopes` to store the slopes.\n- Looping variable `i` goes from 1 to 3 (3 columns, thus 3 slopes):\n\n::: {.cell}\n\n```{.r .cell-code}\nslopes <- numeric(3)\nfor (i in 1:3) {\n  d %>% pull(i) -> xx\n  slopes[i] <- slope(xx, my_df$y)\n}\nslopes\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  1.1000000 -1.1000000  0.5140187\n```\n:::\n:::\n\n\n- Check this by doing the three `lm`s, one at a time.\n\n## The `map_dbl` way\n- In words: for each of these (columns of `d`), run function (`slope`) with inputs\n\"it\" and `y`), and collect together the answers.\n- Since slope returns a decimal number (a `dbl`), appropriate\nfunction-running function is `map_dbl`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap_dbl(d, \\(d) slope(d, my_df$y))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        x1         x2         x3 \n 1.1000000 -1.1000000  0.5140187 \n```\n:::\n:::\n\n\n- Same as loop, with a lot less coding.\n\n## Square roots\n\n- “Find the square roots of each of the numbers 1 through 10”:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1:10\nmap_dbl(x, \\(x) sqrt(x))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 1.000000 1.414214 1.732051 2.000000 2.236068 2.449490 2.645751 2.828427\n [9] 3.000000 3.162278\n```\n:::\n:::\n\n\n## Summarizing all columns of a data frame, two ways\n\n- use my `d` from above: \n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap_dbl(d, \\(d) mean(d))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  x1   x2   x3 \n2.50 6.50 5.25 \n```\n:::\n\n```{.r .cell-code}\nd %>% summarize(across(everything(), \\(x) mean(x)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 3\n     x1    x2    x3\n  <dbl> <dbl> <dbl>\n1   2.5   6.5  5.25\n```\n:::\n:::\n\n\nThe mean of each column, with the columns labelled. \n\n## What if summary returns more than one thing?\n- For example, finding quartiles:\n\n::: {.cell}\n\n```{.r .cell-code}\nquartiles <- function(x) {\n  quantile(x, c(0.25, 0.75))\n}\nquartiles(1:5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n25% 75% \n  2   4 \n```\n:::\n:::\n\n\n- When function returns more than one thing, `map` (or `map_df`) instead\nof `map_dbl`.\n\n## map results\n- Try:\n\n::: {.cell}\n\n```{.r .cell-code}\nmap(d, \\(d) quartiles(d))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$x1\n 25%  75% \n1.75 3.25 \n\n$x2\n 25%  75% \n5.75 7.25 \n\n$x3\n 25%  75% \n3.50 6.75 \n```\n:::\n:::\n\n\n- A list. \n\n## Or\n\n- Better: pretend output from quartiles is one-column data\nframe: \n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap_df(d, \\(d) quartiles(d))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 2\n  `25%` `75%`\n  <dbl> <dbl>\n1  1.75  3.25\n2  5.75  7.25\n3  3.5   6.75\n```\n:::\n:::\n\n\n## Or even\n\n::: {.cell}\n\n```{.r .cell-code}\nd %>% map_df(\\(d) quartiles(d))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 2\n  `25%` `75%`\n  <dbl> <dbl>\n1  1.75  3.25\n2  5.75  7.25\n3  3.5   6.75\n```\n:::\n:::\n\n\n## Comments\n\n- This works because the implicit first thing in map is (the columns of) the\ndata frame that came out of the previous step.\n- These are 1st and 3rd quartiles of each column of `d`, according to R’s\ndefault definition (see help for `quantile`).\n\n## `Map` in data frames with `mutate`\n- `map` can also be used within data frames to calculate new columns.\nLet’s do the square roots of 1 through 10 again:\n\n::: {.cell}\n\n```{.r .cell-code}\nd <- tibble(x = 1:10)\nd %>% mutate(root = map_dbl(x, \\(x) sqrt(x)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 10 × 2\n       x  root\n   <int> <dbl>\n 1     1  1   \n 2     2  1.41\n 3     3  1.73\n 4     4  2   \n 5     5  2.24\n 6     6  2.45\n 7     7  2.65\n 8     8  2.83\n 9     9  3   \n10    10  3.16\n```\n:::\n:::\n\n\n## Write a function first and then map it\n- If the “for each” part is simple, go ahead and use `map_`-whatever.\n- If not, write a function to do the complicated thing first.\n- Example: “half or triple plus one”: if the input is an even number,\nhalve it; if it is an odd number, multiply it by three and add one.\n- This is hard to do as a one-liner: first we have to figure out whether\nthe input is odd or even, and then we have to do the right thing with\nit.\n\n## Odd or even?\n\n\n- Odd or even? Work out the remainder when dividing by 2:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n6 %% 2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0\n```\n:::\n\n```{.r .cell-code}\n5 %% 2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n:::\n\n\n- 5 has remainder 1 so it is odd.\n\n## Write the function\n- First test for integerness, then test for odd or even, and then do the appropriate calculation:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhotpo <- function(x) {\n  stopifnot(round(x) == x) # passes if input an integer\n  remainder <- x %% 2\n  if (remainder == 1) {\n    ans <- 3 * x + 1\n  }\n  else {\n    ans <- x %/% 2 # integer division\n  }\n  ans\n}\n```\n:::\n\n\n## Test it \n\n\n::: {.cell}\n\n```{.r .cell-code}\nhotpo(3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 10\n```\n:::\n\n```{.r .cell-code}\nhotpo(12)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 6\n```\n:::\n\n```{.r .cell-code}\nhotpo(4.5)\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in hotpo(4.5): round(x) == x is not TRUE\n```\n:::\n:::\n\n\n\n## One through ten\n- Use a data frame of numbers 1 through 10 again:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntibble(x = 1:10) %>% mutate(y = map_int(x, \\(x) hotpo(x)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 10 × 2\n       x     y\n   <int> <int>\n 1     1     4\n 2     2     1\n 3     3    10\n 4     4     2\n 5     5    16\n 6     6     3\n 7     7    22\n 8     8     4\n 9     9    28\n10    10     5\n```\n:::\n:::\n\n\n## Until I get to 1 (if I ever do) {.smaller}\n- If I start from a number, find `hotpo` of it, then find `hotpo` of that,\nand keep going, what happens?\n- If I get to 4, 2, 1, 4, 2, 1 I’ll repeat for ever, so let’s stop when we get\nto 1:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhotpo_seq <- function(x) {\n  ans <- x\n  while (x != 1) {\n    x <- hotpo(x)\n    ans <- c(ans, x)\n  }\n  ans\n}\n```\n:::\n\n\n- Strategy: keep looping “while `x` is not 1”.\n- Each new `x`: add to the end of `ans`. When I hit 1, I break\nout of the `while` and return the whole `ans`. \n\n## Trying it 1/2\n- Start at 6:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhotpo_seq(6)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  6  3 10  5 16  8  4  2  1\n```\n:::\n:::\n\n\n## Trying it 2/2 \n\n- Start at 27:\n\n\n::: {.cell}\n\n:::\n\n\n\n\\footnotesize\n\n::: {.cell}\n\n```{.r .cell-code}\nhotpo_seq(27)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  [1]   27   82   41  124   62   31   94   47  142   71  214\n [12]  107  322  161  484  242  121  364  182   91  274  137\n [23]  412  206  103  310  155  466  233  700  350  175  526\n [34]  263  790  395 1186  593 1780  890  445 1336  668  334\n [45]  167  502  251  754  377 1132  566  283  850  425 1276\n [56]  638  319  958  479 1438  719 2158 1079 3238 1619 4858\n [67] 2429 7288 3644 1822  911 2734 1367 4102 2051 6154 3077\n [78] 9232 4616 2308 1154  577 1732  866  433 1300  650  325\n [89]  976  488  244  122   61  184   92   46   23   70   35\n[100]  106   53  160   80   40   20   10    5   16    8    4\n[111]    2    1\n```\n:::\n:::\n\n\\normalsize\n\n\n::: {.cell}\n\n:::\n\n\n\n## Which starting points have the longest sequences?\n- The `length` of the vector returned from `hotpo_seq` says how long it\ntook to get to 1.\n- Out of the starting points 1 to 100, which one has the longest\nsequence?\n\n## Top 10 longest sequences\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntibble(start = 1:100) %>%\n  mutate(seq_length = map_int(\n    start, \\(start) length(hotpo_seq(start)))) %>%\n  slice_max(seq_length, n = 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 10 × 2\n   start seq_length\n   <int>      <int>\n 1    97        119\n 2    73        116\n 3    54        113\n 4    55        113\n 5    27        112\n 6    82        111\n 7    83        111\n 8    41        110\n 9    62        108\n10    63        108\n```\n:::\n:::\n\n\n- 27 is an unusually low starting point to have such a long sequence.\n\n## What happens if we save the entire sequence? \n\n\n::: {.cell}\n\n```{.r .cell-code}\ntibble(start = 1:7) %>%\n  mutate(sequence = map(start, \\(start) hotpo_seq(start)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 7 × 2\n  start sequence  \n  <int> <list>    \n1     1 <int [1]> \n2     2 <dbl [2]> \n3     3 <dbl [8]> \n4     4 <dbl [3]> \n5     5 <dbl [6]> \n6     6 <dbl [9]> \n7     7 <dbl [17]>\n```\n:::\n:::\n\n\n\n- Each entry in `sequence` is itself a vector. `sequence` is a\n“list-column”.\n\n## Using the whole sequence to find its length and its max \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntibble(start = 1:7) %>%\n  mutate(sequence = map(start, \\(start) hotpo_seq(start))) %>%\n  mutate(\n    seq_length = map_int(sequence, \\(sequence) length(sequence)),\n    seq_max = map_int(sequence, \\(sequence) max(sequence))\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 7 × 4\n  start sequence   seq_length seq_max\n  <int> <list>          <int>   <int>\n1     1 <int [1]>           1       1\n2     2 <dbl [2]>           2       2\n3     3 <dbl [8]>           8      16\n4     4 <dbl [3]>           3       4\n5     5 <dbl [6]>           6      16\n6     6 <dbl [9]>           9      16\n7     7 <dbl [17]>         17      52\n```\n:::\n:::\n\n\n\n\n## Does it work with `rowwise`?\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntibble(start=1:7) %>% \n  rowwise() %>% \n  mutate(sequence = list(hotpo_seq(start))) %>% \n  mutate(seq_length = length(sequence)) %>% \n  mutate(seq_max = max(sequence))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 7 × 4\n# Rowwise: \n  start sequence   seq_length seq_max\n  <int> <list>          <int>   <dbl>\n1     1 <int [1]>           1       1\n2     2 <dbl [2]>           2       2\n3     3 <dbl [8]>           8      16\n4     4 <dbl [3]>           3       4\n5     5 <dbl [6]>           6      16\n6     6 <dbl [9]>           9      16\n7     7 <dbl [17]>         17      52\n```\n:::\n:::\n\n\nIt does.\n\n## Final thoughts on this\n- Called the **Collatz conjecture**.\n- Nobody knows whether the sequence always gets to 1.\n- Nobody has found an $n$ for which it doesn’t.\n- A [tree](https://www.jasondavies.com/collatz-graph/).\n",
    "supporting": [
      "functions_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}