{
  "hash": "7873a49b15947be5cc84c66baa08dcdb",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Functions\"\neditor: \n  markdown: \n    wrap: 72\n---\n\n\n\n\n## Packages for this section\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(broom) # some regression stuff later\n```\n:::\n\n\n\n\n## Don’t repeat yourself\n\n-   See this:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- 50\nb <- 11\nd <- 3\nas <- sqrt(a - 1)\nas\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 7\n```\n\n\n:::\n\n```{.r .cell-code}\nbs <- sqrt(b - 1)\nbs\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3.162278\n```\n\n\n:::\n\n```{.r .cell-code}\nds <- sqrt(d - 1)\nds\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.414214\n```\n\n\n:::\n:::\n\n\n\n\n## What's the problem?\n\n-   Same calculation done three different times, by copying, pasting and\n    editing.\n\n-   Dangerous: what if you forget to change something after you pasted?\n\n-   Programming principle: \"don't repeat yourself\".\n\n-   Hadley Wickham: don't copy-paste more than twice.\n\n-   Instead: *write a function*.\n\n## Anatomy of function\n\n-   Header line with function name and input value(s).\n-   Body with calculation of values to output/return.\n-   Return value: the output from function. In our case:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsqrt_minus_1 <- function(x) {\n  ans <- sqrt(x - 1)\n  return(ans)\n}\n```\n:::\n\n\n\n\nor more simply (\"the R way\", better style)\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsqrt_minus_1 <- function(x) {\n  sqrt(x - 1)\n}\n```\n:::\n\n\n\n\nIf last line of function calculates value without saving it, that value\nis returned.\n\n## About the input; testing 1/2\n\n-   The input to a function can be called anything. Here we called it\n    `x`. This is the name used inside the function.\n-   The function is a “machine” for calculating square-root-minus-1. It\n    doesn’t do anything until you call it:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsqrt_minus_1(50)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 7\n```\n\n\n:::\n\n```{.r .cell-code}\nsqrt_minus_1(11)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3.162278\n```\n\n\n:::\n\n```{.r .cell-code}\nsqrt_minus_1(3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.414214\n```\n\n\n:::\n:::\n\n\n\n\n## Testing 2/2\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nq <- 17\nsqrt_minus_1(q)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4\n```\n\n\n:::\n\n```{.r .cell-code}\nsqrt_minus_1(\"text\")\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in x - 1: non-numeric argument to binary operator\n```\n\n\n:::\n:::\n\n\n\n\n-   It works! (At least, it works when it should and fails when it should.)\n\n## Vectorization 1/2\n\n-   We conceived our function to work on numbers:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsqrt_minus_1(3.25)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.5\n```\n\n\n:::\n:::\n\n\n\n\n-   but it actually works on vectors too, as a free bonus of R:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsqrt_minus_1(c(50, 11, 3))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 7.000000 3.162278 1.414214\n```\n\n\n:::\n:::\n\n\n\n\n-   or... (over)\n\n## Vectorization 2/2\n\n-   or even data frames:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd <- tibble(x = 1:2, y = 3:4)\nd\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 x 2\n      x     y\n  <int> <int>\n1     1     3\n2     2     4\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsqrt_minus_1(d)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  x        y\n1 0 1.414214\n2 1 1.732051\n```\n\n\n:::\n:::\n\n\n\n\n## More than one input\n\n-   Allow the value to be subtracted, before taking square root, to be\n    input to function as well, thus:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsqrt_minus_value <- function(x, d) {\n  sqrt(x - d)\n}\n```\n:::\n\n\n\n\n-   Call the function with the x and d inputs in the right order:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsqrt_minus_value(51, 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 7\n```\n\n\n:::\n:::\n\n\n\n\n-   or give the inputs names, in which case they can be in *any order*:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsqrt_minus_value(d = 2, x = 51)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 7\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nd\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 x 2\n      x     y\n  <int> <int>\n1     1     3\n2     2     4\n```\n\n\n:::\n\n```{.r .cell-code}\nd.1 <- lm(y ~ x, data = d)\nsummary(d.1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nCall:\nlm(formula = y ~ x, data = d)\n\nResiduals:\nALL 2 residuals are 0: no residual degrees of freedom!\n\nCoefficients:\n            Estimate Std. Error t value Pr(>|t|)\n(Intercept)        2        NaN     NaN      NaN\nx                  1        NaN     NaN      NaN\n\nResidual standard error: NaN on 0 degrees of freedom\nMultiple R-squared:      1,\tAdjusted R-squared:    NaN \nF-statistic:   NaN on 1 and 0 DF,  p-value: NA\n```\n\n\n:::\n:::\n\n\n\n\n## Defaults 1/2\n\n-   Many R functions have values that you can change if you want to, but\n    usually you don’t want to, for example:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(3, 4, 5, NA, 6, 7)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  3  4  5 NA  6  7\n```\n\n\n:::\n\n```{.r .cell-code}\nmean(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n\n```{.r .cell-code}\nmean(x, na.rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5\n```\n\n\n:::\n:::\n\n\n\n\n-   By default, the mean of data with a missing value is missing, but if\n    you specify `na.rm=TRUE`, the missing values are removed before the\n    mean is calculated.\n\n-   That is, `na.rm` has a default value of `FALSE`: that’s what it will\n    be unless you change it.\n\n## Defaults 2/2\n\n-   In our function, set a default value for d like this:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsqrt_minus_value <- function(x, d = 1) {\n  sqrt(x - d)\n}\n```\n:::\n\n\n\n\n-   If you specify a value for d, it will be used. If you don't, 1 will\n    be used instead:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsqrt_minus_value(51, 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 7\n```\n\n\n:::\n\n```{.r .cell-code}\nsqrt_minus_value(51)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 7.071068\n```\n\n\n:::\n:::\n\n\n\n\n## Catching errors before they happen\n\n-   What happened here?\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsqrt_minus_value(6, 8)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in sqrt(x - d): NaNs produced\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NaN\n```\n\n\n:::\n:::\n\n\n\n\n-   Message not helpful. Actually, function tried to take square root of\n    negative number.\n-   In fact, not even error, just warning.\n-   Check that the square root will be OK first. Here’s how:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsqrt_minus_value <- function(x, d = 1) {\n  stopifnot(x - d >= 0)\n  sqrt(x - d)\n}\n```\n:::\n\n\n\n\n## What happens with `stopifnot`\n\n-   This should be good, and is:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsqrt_minus_value(8, 6)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.414214\n```\n\n\n:::\n:::\n\n\n\n\n-   This should fail, and see how it does:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsqrt_minus_value(6, 8)\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in sqrt_minus_value(6, 8): x - d >= 0 is not TRUE\n```\n\n\n:::\n:::\n\n\n\n\n-   Where the function fails, we get informative error, but if\n    everything good, the `stopifnot` does nothing.\n-   `stopifnot` contains one or more logical conditions, and all of them\n    have to be true for function to work. So put in everything that you\n    want to be true.\n\n## Using R’s built-ins\n\n-   When you write a function, you can use anything built-in to R, or\n    even any functions that you defined before.\n-   For example, if you will be calculating a lot of regression-line\n    slopes, you don’t have to do this from scratch: you can use R’s\n    regression calculations, like this:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_df <- tibble(x = 1:4, y = c(10, 11, 10, 14))\nmy_df\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 x 2\n      x     y\n  <int> <dbl>\n1     1    10\n2     2    11\n3     3    10\n4     4    14\n```\n\n\n:::\n:::\n\n\n\n\n## Running the regression\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_df.1 <- lm(y ~ x, data = my_df)\ntidy(my_df.1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 x 5\n  term        estimate std.error statistic p.value\n  <chr>          <dbl>     <dbl>     <dbl>   <dbl>\n1 (Intercept)      8.5     1.88       4.53  0.0455\n2 x                1.1     0.686      1.60  0.250 \n```\n\n\n:::\n:::\n\n\n\n\n\n## Pulling out just the slope\n\nUse `pluck`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntidy(my_df.1) %>% pluck(\"estimate\", 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.1\n```\n\n\n:::\n:::\n\n\n\n\n## Making this into a function\n\n-   First step: make sure you have it working without a function (we do)\n-   Inputs: two, an `x` and a `y`.\n-   Output: just the slope, a number. Thus:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nslope <- function(xx, yy) {\n  y.1 <- lm(yy ~ xx)\n  tidy(y.1) %>% pluck(\"estimate\", 2)\n}\n```\n:::\n\n\n\n\n-   Check using our data from before: correct:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwith(my_df, slope(x, y))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.1\n```\n\n\n:::\n:::\n\n\n\n\n## Passing things on\n\n-   `lm` has a lot of options, with defaults, that we might want to\n    change. Instead of intercepting all the possibilities and passing\n    them on, we can do this:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nslope <- function(xx, yy, ...) {\n  y.1 <- lm(yy ~ xx, ...)\n  tidy(y.1) %>% pluck(\"estimate\", 2)\n}\n```\n:::\n\n\n\n\n-   The `...` in the header line means “accept any other input”, and the\n    `...` in the `lm` line means “pass anything other than `x` and `y`\n    straight on to `lm`”.\n\n## Using `...`\n\n-   One of the things `lm` will accept is a vector called `subset`\n    containing the list of observations to include in the regression.\n-   So we should be able to do this:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwith(my_df, slope(x, y, subset = 3:4))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4\n```\n\n\n:::\n:::\n\n\n\n\n-   Just uses the last two observations in `x` and `y`:\n\n\\small\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_df %>% slice(3:4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 x 2\n      x     y\n  <int> <dbl>\n1     3    10\n2     4    14\n```\n\n\n:::\n:::\n\n\n\n\n\\footnotesize\n\n-   so the slope should be $(14 − 10)/(4 − 3) = 4$ and is.\n\n## What happens here?\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwith(my_df, slope(x, y, hair = \"spiky\"))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: In lm.fit(x, y, offset = offset, singular.ok = singular.ok, ...) :\n extra argument 'hair' will be disregarded\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.1\n```\n\n\n:::\n:::\n\n\n\n\n- Where did the warning come from?\n\n\n## Running a function for each of several inputs\n\n-   Suppose we have a data frame containing several different `x`’s to\n    use in regressions, along with the `y` we had before:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(d <- tibble(x1 = 1:4, x2 = c(8, 7, 6, 5), x3 = c(2, 4, 6, 9)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 x 3\n     x1    x2    x3\n  <int> <dbl> <dbl>\n1     1     8     2\n2     2     7     4\n3     3     6     6\n4     4     5     9\n```\n\n\n:::\n:::\n\n\n\n\n-   Want to use these as different x’s for a regression with `y` from\n    `my_df` as the response, and collect together the three different\n    slopes.\n-   Python-like way: a `for` loop.\n-   R-like way: `map_dbl`: less coding, but more thinking.\n\n## The loop way\n\n-   “Pull out” column `i` of data frame `d` as `d %>% pull(i)`.\n-   Create empty vector `slopes` to store the slopes.\n-   Looping variable `i` goes from 1 to 3 (3 columns, thus 3 slopes):\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nslopes <- numeric(3)\nfor (i in 1:3) {\n  d %>% pull(i) -> xx\n  slopes[i] <- slope(xx, my_df$y)\n}\nslopes\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  1.1000000 -1.1000000  0.5140187\n```\n\n\n:::\n:::\n\n\n\n\n-   Check this by doing the three `lm`s, one at a time.\n\n## The `map_dbl` way\n\n-   In words: for each of these (columns of `d`), run function (`slope`)\n    with inputs \"it\" and `y`), and collect together the answers.\n-   Since slope returns a decimal number (a `dbl`), appropriate\n    function-running function is `map_dbl`:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap_dbl(d, \\(d) slope(d, my_df$y))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n        x1         x2         x3 \n 1.1000000 -1.1000000  0.5140187 \n```\n\n\n:::\n:::\n\n\n\n\n-   Same as loop, with a lot less coding.\n\n## Square roots\n\n-   “Find the square roots of each of the numbers 1 through 10”:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1:10\nmap_dbl(x, \\(x) sqrt(x))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 1.000000 1.414214 1.732051 2.000000 2.236068 2.449490 2.645751 2.828427\n [9] 3.000000 3.162278\n```\n\n\n:::\n:::\n\n\n\n\n## Summarizing all columns of a data frame, two ways\n\n-   use my `d` from above:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap_dbl(d, \\(d) mean(d))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  x1   x2   x3 \n2.50 6.50 5.25 \n```\n\n\n:::\n\n```{.r .cell-code}\nd %>% summarize(across(everything(), \\(x) mean(x)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 x 3\n     x1    x2    x3\n  <dbl> <dbl> <dbl>\n1   2.5   6.5  5.25\n```\n\n\n:::\n:::\n\n\n\n\nThe mean of each column, with the columns labelled.\n\n## What if summary returns more than one thing?\n\n-   For example, finding quartiles:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nquartiles <- function(x) {\n  quantile(x, c(0.25, 0.75))\n}\nquartiles(1:5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n25% 75% \n  2   4 \n```\n\n\n:::\n:::\n\n\n\n\n-   When function returns more than one thing, `map` (or `map_df`)\n    instead of `map_dbl`.\n\n## Map results\n\n-   Try:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap(d, \\(d) quartiles(d)) -> e\ne\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$x1\n 25%  75% \n1.75 3.25 \n\n$x2\n 25%  75% \n5.75 7.25 \n\n$x3\n 25%  75% \n3.50 6.75 \n```\n\n\n:::\n:::\n\n\n\n\n-   A list.\n\n## Or\n\n-   Better: pretend output from quartiles is one-row data frame:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap_df(d, \\(d) quartiles(d))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 x 2\n  `25%` `75%`\n  <dbl> <dbl>\n1  1.75  3.25\n2  5.75  7.25\n3  3.5   6.75\n```\n\n\n:::\n:::\n\n\n\n\n## Or even\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd %>% map_df(\\(d) quartiles(d))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 x 2\n  `25%` `75%`\n  <dbl> <dbl>\n1  1.75  3.25\n2  5.75  7.25\n3  3.5   6.75\n```\n\n\n:::\n:::\n\n\n\n\n## Comments\n\n-   This works because the implicit first thing in map is (the columns\n    of) the data frame that came out of the previous step.\n-   These are 1st and 3rd quartiles of each column of `d`, according to\n    R’s default definition (see help for `quantile`).\n\n## `Map` in data frames with `mutate`\n\n-   `map` can also be used within data frames to calculate new columns.\n    Let’s do the square roots of 1 through 10 again:\n\n\\small\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd <- tibble(x = 1:10)\nd %>% mutate(root = map_dbl(x, \\(x) sqrt(x)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10 x 2\n       x  root\n   <int> <dbl>\n 1     1  1   \n 2     2  1.41\n 3     3  1.73\n 4     4  2   \n 5     5  2.24\n 6     6  2.45\n 7     7  2.65\n 8     8  2.83\n 9     9  3   \n10    10  3.16\n```\n\n\n:::\n:::\n\n\n\n\n\\normalsize\n\n## Write a function first and then map it\n\n-   If the “for each” part is simple, go ahead and use `map_`-whatever.\n-   If not, write a function to do the complicated thing first.\n-   Example: “half or triple plus one”: if the input is an even number,\n    halve it; if it is an odd number, multiply it by three and add one.\n-   This is hard to do as a one-liner: first we have to figure out\n    whether the input is odd or even, and then we have to do the right\n    thing with it.\n\n## Odd or even?\n\n-   Odd or even? Work out the remainder when dividing by 2:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n6 %% 2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0\n```\n\n\n:::\n\n```{.r .cell-code}\n5 %% 2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n:::\n\n\n\n\n-   5 has remainder 1 so it is odd.\n\n## Write the function\n\n-   First test for integerness, then test for odd or even, and then do\n    the appropriate calculation:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhotpo <- function(x) {\n  stopifnot(round(x) == x) # passes if input an integer\n  remainder <- x %% 2\n  if (remainder == 1) { # odd number\n    ans <- 3 * x + 1\n  }\n  else { # even number\n    ans <- x %/% 2 # integer division\n  }\n  ans\n}\n```\n:::\n\n\n\n\n\n## Test it\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhotpo(3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10\n```\n\n\n:::\n\n```{.r .cell-code}\nhotpo(12)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 6\n```\n\n\n:::\n\n```{.r .cell-code}\nhotpo(4.5)\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in hotpo(4.5): round(x) == x is not TRUE\n```\n\n\n:::\n:::\n\n\n\n\n## One through ten\n\n-   Use a data frame of numbers 1 through 10 again:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntibble(x = 1:10) %>% mutate(y = map_int(x, \\(x) hotpo(x)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10 x 2\n       x     y\n   <int> <int>\n 1     1     4\n 2     2     1\n 3     3    10\n 4     4     2\n 5     5    16\n 6     6     3\n 7     7    22\n 8     8     4\n 9     9    28\n10    10     5\n```\n\n\n:::\n:::\n\n\n\n\n## Until I get to 1 (if I ever do) {.smaller}\n\n-   If I start from a number, find `hotpo` of it, then find `hotpo` of\n    that, and keep going, what happens?\n-   If I get to 4, 2, 1, 4, 2, 1 I’ll repeat for ever, so let’s stop\n    when we get to 1:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhotpo_seq <- function(x) {\n  ans <- x\n  while (x != 1) {\n    x <- hotpo(x)\n    ans <- c(ans, x)\n  }\n  ans\n}\n```\n:::\n\n\n\n\n-   Strategy: keep looping “while `x` is not 1”.\n-   Each new `x`: add to the end of `ans`. When I hit 1, I break out of\n    the `while` and return the whole `ans`.\n\n## Trying it 1/2\n\n-   Start at 6:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhotpo_seq(6)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  6  3 10  5 16  8  4  2  1\n```\n\n\n:::\n:::\n\n\n\n\n## Trying it 2/2\n\n-   Start at 27:\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\n\\footnotesize\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhotpo_seq(27)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  [1]   27   82   41  124   62   31   94   47  142   71  214\n [12]  107  322  161  484  242  121  364  182   91  274  137\n [23]  412  206  103  310  155  466  233  700  350  175  526\n [34]  263  790  395 1186  593 1780  890  445 1336  668  334\n [45]  167  502  251  754  377 1132  566  283  850  425 1276\n [56]  638  319  958  479 1438  719 2158 1079 3238 1619 4858\n [67] 2429 7288 3644 1822  911 2734 1367 4102 2051 6154 3077\n [78] 9232 4616 2308 1154  577 1732  866  433 1300  650  325\n [89]  976  488  244  122   61  184   92   46   23   70   35\n[100]  106   53  160   80   40   20   10    5   16    8    4\n[111]    2    1\n```\n\n\n:::\n:::\n\n\n\n\n\\normalsize\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\n## Which starting points have the longest sequences?\n\n-   The `length` of the vector returned from `hotpo_seq` says how long\n    it took to get to 1.\n-   Out of the starting points 1 to 100, which one has the longest\n    sequence?\n\n## Top 10 longest sequences\n\n\\footnotesize\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntibble(start = 1:100) %>%\n  mutate(seq_length = map_int(\n    start, \\(start) length(hotpo_seq(start)))) %>%\n  slice_max(seq_length, n = 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10 x 2\n   start seq_length\n   <int>      <int>\n 1    97        119\n 2    73        116\n 3    54        113\n 4    55        113\n 5    27        112\n 6    82        111\n 7    83        111\n 8    41        110\n 9    62        108\n10    63        108\n```\n\n\n:::\n:::\n\n\n\n\n-   27 is an unusually low starting point to have such a long sequence.\n\n## What happens if we save the entire sequence?\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntibble(start = 1:7) %>%\n  mutate(sequence = map(start, \\(start) hotpo_seq(start)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 7 x 2\n  start sequence  \n  <int> <list>    \n1     1 <int [1]> \n2     2 <dbl [2]> \n3     3 <dbl [8]> \n4     4 <dbl [3]> \n5     5 <dbl [6]> \n6     6 <dbl [9]> \n7     7 <dbl [17]>\n```\n\n\n:::\n:::\n\n\n\n\n-   Each entry in `sequence` is itself a vector. `sequence` is a\n    “list-column”.\n\n## Using the whole sequence to find its length and its max\n\n\\small\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntibble(start = 1:7) %>%\n  mutate(sequence = map(start, \\(start) hotpo_seq(start))) %>%\n  mutate(\n    seq_length = map_int(sequence, \\(sequence) length(sequence)),\n    seq_max = map_int(sequence, \\(sequence) max(sequence))\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 7 x 4\n  start sequence   seq_length seq_max\n  <int> <list>          <int>   <int>\n1     1 <int [1]>           1       1\n2     2 <dbl [2]>           2       2\n3     3 <dbl [8]>           8      16\n4     4 <dbl [3]>           3       4\n5     5 <dbl [6]>           6      16\n6     6 <dbl [9]>           9      16\n7     7 <dbl [17]>         17      52\n```\n\n\n:::\n:::\n\n\n\n\n\n\n## Does it work with `rowwise`?\n\n\\small\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntibble(start=1:7) %>% \n  rowwise() %>% \n  mutate(sequence = list(hotpo_seq(start))) %>% \n  mutate(seq_length = length(sequence)) %>% \n  mutate(seq_max = max(sequence))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 7 x 4\n# Rowwise: \n  start sequence   seq_length seq_max\n  <int> <list>          <int>   <dbl>\n1     1 <int [1]>           1       1\n2     2 <dbl [2]>           2       2\n3     3 <dbl [8]>           8      16\n4     4 <dbl [3]>           3       4\n5     5 <dbl [6]>           6      16\n6     6 <dbl [9]>           9      16\n7     7 <dbl [17]>         17      52\n```\n\n\n:::\n:::\n\n\n\n\n\\normalsize\n\nIt does.\n\n## Final thoughts on this\n\n-   Called the **Collatz conjecture**.\n-   Nobody knows whether the sequence always gets to 1.\n-   Nobody has found an $n$ for which it doesn’t.\n-   A [tree (link)](https://www.jasondavies.com/collatz-graph/).\n",
    "supporting": [
      "functions_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": null,
    "postProcess": false
  }
}